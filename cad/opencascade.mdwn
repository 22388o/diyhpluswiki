# opencascade

The [opencascade](http://opencascade.org/) [source code](https://github.com/tpaviot/oce) is written in a combination of Russian, French and English since the late 1980s starting at Matra Datavision. [Upstream](http://dev.opencascade.org/) has a Mantis [bug tracker](http://tracker.dev.opencascade.org/view_all_bug_page.php).

* <http://opencascade.org/>
* <http://dev.opencascade.org/>
* <https://github.com/tpaviot/oce> ("opencascade community edition")
* <http://tracker.dev.opencascade.org/view_all_bug_page.php>

also:

* <http://dev.opencascade.org/doc/overview/html/occt_user_guides__modeling_algos.html>
* <http://dev.opencascade.org/doc/overview/html/occt_user_guides__boolean_operations.html>

# overview

See the [documentation](http://dev.opencascade.org/doc/overview/html/technical_overview.html).

## package naming conventions

* P(name) - persistence models, for storing to file or database
* T(name) - transient data structures
* Mgt(name) - helpers for converting between persisted and non-persisted classes
* (name)DRAW - command wrappers to expose access to functions for DRAWEXE
* TK(name) - toolkit, has only the following files: EXTERNLIB, FILES, PACKAGES; this was probably their attempt at making the code more accessible?
* QA(name) - hardcoded bug-specific regression testing code for "quality assurance"
* Test - dunno, maybe relatied to regression testing?
* (name)DS - probably about data structures, classes, objects, models, definitions

## abbreviations

<table>
    <tr>
        <th>abbreviation</th>
        <th>meaning</th>
    </tr>
    <tr><td>n</td><td>number</td></tr>
    <tr><td>Dim</td><td>dimension</td></tr>
    <tr><td>P</td><td>point</td></tr>
    <tr><td>P</td><td>persistence</td></tr>
    <tr><td>T</td><td>transience</td></tr>
    <tr><td>Pnt</td><td>point</td></tr>
    <tr><td>V</td><td>vertex</td></tr>
    <tr><td>E</td><td>edge</td></tr>
    <tr><td>C</td><td>curve</td></tr>
    <tr><td>F</td><td>face</td></tr>
    <tr><td>Surf</td><td>surface</td></tr>
    <tr><td>DS</td><td>data structure</td></tr>
    <tr><td>Col</td><td>collection</td></tr>
    <tr><td>Coll</td><td>collection</td></tr>
    <tr><td>Prop</td><td>properties</td></tr>
    <tr><td>TK</td><td>toolkit</td></tr>
    <tr><td>QA</td><td>quality assurance</td></tr>
    <tr><td>Mgt</td><td>management</td></tr>
    <tr><td>Mgr</td><td>manager?</td></tr>
    <tr><td>Algo</td><td>algorithm</td></tr>
    <tr><td>Gen</td><td>generation/generator</td></tr>
    <tr><td>Iter</td><td>iterator/iteration</td></tr>
    <tr><td>Lib</td><td>library</td></tr>
    <tr><td>API</td><td>application programming interface</td></tr>
    <tr><td>Std</td><td>standard</td></tr>
    <tr><td>CDL</td><td>cascade definition language</td></tr>
    <tr><td>STL</td><td>standard tessellation language</td></tr>
    <tr><td>Geom</td><td>geometry</td></tr>
    <tr><td>Topo</td><td>topology</td></tr>
    <tr><td>Top</td><td>topology?</td></tr>
    <tr><td>BRep</td><td>boundary representation</td></tr>
    <tr><td>gp</td><td>geometric processor</td></tr>
    <tr><td>BSpline</td><td>bezier spline</td></tr>
    <tr><td>NURBS</td><td>non-uniform rational bsplines</td></tr>
    <tr><td>BOP</td><td>boolean operation?</td></tr>
    <tr><td>Approx</td><td>approximation</td></tr>
    <tr><td>Func</td><td>function</td></tr>
    <tr><td>Int</td><td>intersections</td></tr>
    <tr><td>int</td><td>integer</td></tr>
    <tr><td>Trans</td><td>transitions?</td></tr>
    <tr><td>Ope</td><td>operations</td></tr>
    <tr><td>Proj</td><td>projections</td></tr>
    <tr><td>Prim</td><td>primitives (shapes, geometry, etc.)</td></tr>
    <tr><td>ChFi</td><td>chamfers and fillets</td></tr>
    <tr><td>SH</td><td>shape healing</td></tr>
    <tr><td>HLR</td><td>hidden lines removal</td></tr>
    <tr><td>Prs</td><td>presentation</td></tr>
    <tr><td>WNT</td><td>Windows NT</td></tr>
    <tr><td>Ctl</td><td>control</td></tr>
    <tr><td>FE</td><td>finite element</td></tr>
    <tr><td>Cnx</td><td>???</td></tr>
</table>

## geometry

* Convert provides:
* * a bounded curve based on an elementary 2D curve (line, circle or conic) from the gp package,
* * a bounded surface based on an elementary surface (cylinder, cone, sphere or torus) from the gp package,
* * a series of adjacent 2D or 3D Bezier curves defined by their poles.

* Geom2dConvert provides:
* * a global function which is used to construct a BSpline curve from a bounded curve based on a 2D curve from the Geom2d package,
* * a splitting algorithm which computes the points at which a 2D BSpline curve should be cut in order to obtain arcs with the same degree of continuity,
* * global functions used to construct the BSpline curves created by this splitting algorithm, or by other types of segmentation of the BSpline curve,
* * an algorithm which converts a 2D BSpline curve into a series of adjacent Bezier curves.

* GeomConvert provides:
* * a global function used to construct a BSpline curve from a bounded curve based on a curve from the Geom package,
* * a splitting algorithm, which computes the points at which a BSpline curve should be cut in order to obtain arcs with the same degree of continuity,
* * global functions to construct BSpline curves created by this splitting algorithm, or by other types of BSpline curve segmentation,
* * an algorithm, which converts a BSpline curve into a series of adjacent Bezier curves,
* * a global function to construct a BSpline surface from a bounded surface based on a surface from the Geom package,
* * a splitting algorithm, which determines the curves along which a BSpline surface should be cut in order to obtain patches with the same degree of continuity,
* * global functions to construct BSpline surfaces created by this splitting algorithm, or by other types of BSpline surface segmentation,
* * an algorithm, which converts a BSpline surface into a series of adjacent Bezier surfaces,
* * an algorithm, which converts a grid of adjacent Bezier surfaces into a BSpline surface.

## topology

Topology defines the relationship between simple geometric entities, which can thus be linked together to represent complex shapes.

### primitives

* 0D entities such as points;
* 1D entities such as curves;
* 2D entities such as surfaces;
* 3D entities such as volumes.

which consist of:

* Vertex - a zero-dimensional shape corresponding to a point in geometry;
* Edge - a shape corresponding to a curve, and bound by a vertex at each extremity;
* Wire - a sequence of edges connected by their vertices;
* Face - part of a plane (in 2D geometry) or a surface (in 3D geometry) bounded by a closed wire;
* Shell - a collection of faces connected by some edges of their wire boundaries;
* Solid - a part of 3D space bound by a shell;
* Compound solid - a collection of solids.

A face with 3D underlying geometry may also refer to a collection of connected triangles that approximate the underlying surface. The surfaces can be undefined leaving the faces represented by triangles only. If so, the model is purely polyhedral.

### topology packages

* TopAbs - topological shape, orientation and state
* TopLoc - 3D local coordinate systems (Datum3D and Location); Datum3D describes an elementary coordinate system, while Location comprises a series of elementary coordinate systems.
* TopoDS - data structures for modeling (see also TopExp); you will often use TopoDS\_Shape

There are some other topology-related packages that build on top of TopAbs, TopLoc and TopoDS:

* TopTools - basic tools
* TopExp - classes to explore and manipulate the topological data structures described in the TopoDS package
* BRepTools - classes to explore, manipulate, read and write BRep data structures. These more complex data structures combine topological descriptions with additional geometric information, and include rules for evaluating equivalence of different possible representations of the same object, for example, a point.

## algorithms

Algorithms are classified into the following categories in opencascade:

* analytic algorithms, where solutions are obtained by the resolution of an equation, such algorithms are used when the geometries which are worked on (tangency arguments, position of the center, etc.) are points, lines or circles;
* geometric algorithms, where the solution is generally obtained by calculating the intersection of parallel or bisecting curves built from geometric arguments;
* iterative algorithms, where the solution is obtained by a process of iteration.

For geometric construction of a constrained line or constrained circle, the following packages compute all solutions (except for those solutions that can only be found by the iterative algorithms):

* Geom2dGcc - automatically selects an algorithm for the problem, inputs are Geom2d objects and the computed solutions are gp objects (qualified curves for tangency can be provided by Geom2dGcc)
* GccAna - analytical algorithms, can only be used for geometries of lines and circles, both the input and output types are gp objects (qualified curves for tangency are provided by GccEnt); also maybe GccInt is used or it may be a typo for GccEnt

Iterative algorithms compute only one solution, closest to an initial position:

* to build a circle, when an argument is more complex than a line or a circle, and where the radius is not known or difficult to determine: this is the case for a circle tangential to three geometric elements, or tangential to two geometric elements and centered on a curve;
* to build a line, when a tangency argument is more complex than a line or a circle.

Curves used by GccAna algorithms to define the geometric problem to be solved, are 2D lines or circles from the gp package: they are not explicitly parameterized. However, these lines or circles retain an implicit parameterization, corresponding to that which they induce on equivalent Geom2d objects. This induced parameterization is the one used when returning parameter values on such curves, for instance with the functions Tangency1, Tangency2, Tangency3, Intersection2 and CenterOn3 provided by construction algorithms from the GccAna or Geom2dGcc packages.

## topological tools

This is the BRepBuilderAPI package. This library provides algorithms to:

* Tessellate shapes
* Validate shapes
* Determine the local properties of shapes
* Determine the global properties of shapes
* Perform geometric transformations
* Find planes in which edges are located
* Convert shapes to NURBS geometry.

It can create the following topological objects (perhaps using the original topology definitions from the other packages?):

* Vertices
* Edges
* Faces
* Wires
* Polygonal wires
* Shells
* Solids

Use the BRepPrimAPI package to construct primitives such as:

* boxes
* cones
* cylinders
* prisms
* construction by sweeping along a profile (linear and rotational (through an angle of rotation))

Sweeps are objects obtained by sweeping a profile along a path. The profile can be any topology and the path is usually a curve or a wire. The profile generates objects according to the following rules:

* Vertices generate Edges
* Edges generate Faces.
* Wires generate Shells.
* Faces generate Solids.
* Shells generate Composite Solids.

It is not allowed to sweep Solids and Composite Solids. Swept constructions along complex profiles such as BSpline curves also available in the BRepOffsetAPI package. This API provides simple, high level calls for the most common operations.

## boolean operations

Boolean operations allow creating new shapes from old ones by using:

* Common
* Cut
* Fuse
* Section

From the viewpoint of Topology these are topological operations followed by blending (putting fillets onto edges created after the topological operation). Topological operations are the most convenient way to create real industrial parts, as most industrial parts consist of several simple elements such as gear wheels, arms, holes, ribs, tubes and pipes. It is usually easy to create those elements separately and then to combine them by Boolean operations in the whole final part.

There exist two libraries providing Boolean Operations:

* Old Boolean Operations (BOA) provided by BRepAlgo package designed and developed in Open CASCADE 6x in 2000; its architecture and content are out of date.
* New Boolean Operations (NBOA) provided by BRepAlgoAPI package designed and developed in 2001 and completely revised in 2013.

New Boolean Operations provide the following major benefits:

* The NBOA have an expandable architecture of inner sub-algorithms based on the provided general algorithm(s?).
* The architecture of NBOA is history-based. The implementation of NBOA internally sets up a correspondence between any sub-shape of the argument and its image in the result. The history is not imposed and thus it is not error-prone as it was in BOA. The fact allows direct and safely usage of the algorithm in parametric modeling.
* The implementation of NBOA is based on NCollection classes. The usage of opportunities given by local memory allocators (NCollection\_IncAllocator) allows improving memory management and saving memory resources.
* NBOA use modern algorithms of OCC as auxiliary tools. For e.g. the algorithm of unbalanced binary tree of overlapped bounding boxes (NCollection\_UBTree). The usage of the algorithm allows to improve the performance of NBOA if there is a big number of sub-shapes in the arguments.

Boolean Operations have the following types of the arguments and produce the following results:

* For arguments having the same shape type (e.g. SOLID / SOLID) the type of the resulting shape will be a COMPOUND, containing shapes of this type.
* For arguments having different shape types (e.g. SHELL / SOLID) the type of the resulting shape will be a COMPOUND, containing shapes of the type that is the same as that of the low type of the argument. Example: For SHELL/SOLID the result is a COMPOUND of SHELLs.
* For arguments with different shape types some of Boolean Operations can not be done using the default implementation, because of a non-manifold type of the result. Example: the FUSE operation for SHELL and SOLID can not be done, but the CUT operation can be done, where SHELL is the object and SOLID is the tool.
* It is possible to perform Boolean Operations on arguments of the COMPOUND shape type. In this case each compound must not be heterogeneous, i.e. it must contain equidimensional shapes (EDGEs or/and WIREs, FACEs or/and SHELLs, SOLIDs). SOLIDs inside the COMPOUND must not contact (intersect or touch) each other. The same condition should be respected for SHELLs or FACEs, WIREs or EDGEs.
* Boolean Operations for COMPSOLID type of shape are not supported.

Packages:

* BOPAlgo\_Builder - General Fuse Algorithm (GFA), see PerformInternal
* BOPAlgo\_BOP - for the Boolean Operation Algorithm (BOA). see PerformInternal

diagram: BOPAlgo\_Bop -> BOPAlgo\_Builder -> BOPAlgo\_BuilderShape -> BOPAlgo\_Algo

The class BOPAlgo\_Algo provides the base interface for all algorithms, including error status, warning status, checking data, result checking, memory allocator.

The class BOPAlgo\_BuilderShape provides the interface for algorithms that have a shape as the result and history information (generated, modified, IsDeleted).

Read up on [modeling algorithms](http://dev.opencascade.org/doc/overview/html/occt_user_guides__modeling_algos.html) and [boolean operations](http://dev.opencascade.org/doc/overview/html/occt_user_guides__boolean_operations.html).

## splitting and gluing

* Split shape allows defining particular faces in a shape and new edges which should split that faces. Upon completion the algorithm gives the part of the shape which is situated on the left side of the line composed from new edges. In combination with the Section algorithm it is a powerful tool for partitioning shapes.
* Glue shapes allows to defining pairs of faces and pairs of edges of two neighboring shapes to glue. Upon completion the algorithm gives the glued shape with cut out parts of faces inside the shape.

## sewing

Sewing allows creation of connected topology (shells and wires) from a set of separate topological elements (faces and edges). For example, Sewing can be used to create of shell from a compound of separate faces. It is important to distinguish between sewing and other procedures, which modify the geometry, such as filling holes or gaps, gluing, bending curves and surfaces, etc. Sewing does not change geometrical representation of the shapes. Sewing applies to topological elements (faces, edges) which are not connected but can be connected because they are geometrically coincident: it adds the information about topological connectivity. Already connected elements are left untouched in case of manifold sewing.

Let us define several terms:

* Floating edges do not belong to any face;
* Free boundaries belong to one face only;
* Shared edges belong to several faces, (i.e. two faces in a manifold topology).
* Sewn faces should have edges shared with each other.
* Sewn edges should have vertices shared with each other.

### sewing algorithms

* BRepAlgo\_Sewing (standard sewing algorithm)
* ShapeUpgrade\_Sewing (a subclass of BRepAlgo\_Sewing) (a more advanced algorithm)

The only difference between them is that Advanced sewing performs some additional fixes provided by Shape Healing (use of ShapeFix\_Shape) and improves some particular cases, such as closed surfaces. The principle and architecture of the algorithm itself remain the same.

Class BRepAlgo\_Sewing provides methods implementing sewing algorithms:

* loading initial data for global or local sewing;
* setting customization parameters, such as special operation modes, tolerances and output results;
* applying analysis methods that can be used to obtain connectivity data required by external algorithms;
* sewing of the loaded shapes.

Sewing supports working mode with big value tolerance. It is not necessary to repeat sewing step by step while smoothly increasing tolerance.

It is also possible to sew edges to wire and to sew locally separate faces and edges from a shape.

The Sewing algorithm can be subdivided into several independent stages, some of which can be turned on or off using Boolean or other flags. In brief, the algorithm should find a find a set of merge candidates for each free boundary, filter them according to certain criteria, and finally merge the found candidates and build the resulting sewn shape. Each stage of the algorithm or the whole algorithm can be adjusted with the following parameters:

* Working tolerance defines the maximal distance between topological elements which can be sewn. It is not ultimate that such elements will be actually sewn as many other criteria are applied to make the final decision.
* Minimal tolerance defines the size of the smallest element (edge) in the resulting shape. It is declared that no edges with size less than this value are created after sewing. If encountered, such topology becomes degenerated.
* Non-manifold mode enables sewing of non-manifold topology.

There are details in the opencascade documentation for tolerance management during sewing, manifold and non-manifold sewing, and local sewing.

## shape healing

geometry and topology debugging, user-guided fixing, etc.

## test harness

DRAWEXE is the "draw test harness". You type tcl into it and it does things. Type "pload ALL" to load all modules (all commands provided by the the Test\* packages). Also it does basic visualization.

## debugging

[debugging hints](http://dev.opencascade.org/doc/overview/html/occt_dev_guides__debug.html)

## boolean operations diagnostics

In real-world applications modeling operations are often performed in a long sequence, while the user sees only the final result of the whole sequence. If the final result is wrong, the first debug step is to identify the offending operation to be debugged further. Boolean operation algorithm in OCCT provides a self-diagnostic feature which can help to do that step.

This feature can be activated by defining environment variable CSF\_DEBUG\_BOP, which should specify an existing writeable directory.

The diagnostic code checks validity of the input arguments and the result of each Boolean operation. When an invalid situation is detected, the report consisting of argument shapes and a DRAW script to reproduce the problematic operation is saved to the directory pointed by CSF\_DEBUG\_BOP.

# hints

## How to extract the underlying geometry from shapes

* BRep\_Tool::Surface to get the geometric surface from a face.
* BRep\_Tool::Curve to get the 3d geometric curve from an edge.
* BRep\_Tool::CurveOnSurface to get the 2d geometric curve of an edge, defined in the parametric space of a face.
* BRep\_Tool::Pnt to get the 3D point from a vertex.

## How to get the coordinates of a vertex

To recover the UV coordinates of vertices, use BRep\_Tool::Parameters(const TopoDS\_Vertex& V, const TopoDS\_Face& F), which returns the U and V parameters of the vertex V on the face F as a gp\_Pnt2d.

## How to explore a wire

A wire is a sequence of edges, so wire exploration will return individual edges. Use BRepTools\_WireExplorer.

<pre>
TopoDS_Wire myWire = ...
BRepTools_WireExplorer Ex;
for (Ex.Init(myWire); Ex.More(); Ex.Next()) {
TopoDS_Edge currentedge = Ex.Current();
// Process current edge
}
</pre>

## How to merge bspline curves

* GeomConvert::ConcatG1 concatenates according to tangency continuity along the curve.
* GeomConvert::ConcatC1 concatenates according to first derivative continuity along the curve.
* using class GeomConvert\_CompCurveToBSplineCurve which provides methods to concatenate several restricted curves to a bspline curve. Non-bspline curves are converted to bspline before concatenation. To add a new curve, use the GeomConvert\_CompCurveToBSplineCurve::Add method. Tolerance is used to check the continuity and decrease the Multiplicity at the common Knot until MinM . If MinM = 0 , the common Knot can be removed. The method to get a result is Handle(Geom\_BSplineCurve) GeomConvert\_CompCurveToBSplineCurve::BSplineCurve() const.

# interesting stuff

Things worth keeping?

* intersection algorithms for both 2d and 3d objects
* boolean operations (the general method is implemented in BRepAlgo\_BOP and the "general fuse algorithm" is implemented in BRepAlgo\_Builder both in the PerformInternal method)
* deprecated boolean operations code: <https://github.com/tpaviot/oce/blob/master/src/BRepAlgo/BRepAlgo_BooleanOperation.cxx>

<div id="BRepAlgo_BOP" />
# BRepAlgo\_BOP

The best way to figure out the BRepAlgo\_BOP boolean operation stuff is to look at it in reverse. The final result of boolean operations is to update an instance variable known as "myShape". So look for where myShape is assigned, and that's basically the last place of the algorithms. The "myRC" and corresponding BuildRC() function might be enough to complete the operation, but if not the BuildShape function will do further things to get to the final "myShape".

The boolean operation algorithms can be manually executed using DRAWEXE by using the BOPTest module (bfuse, bcommon, etc). Also note there are a number of commands to dump BReps to file if necessary.

<https://github.com/tpaviot/oce/tree/master/src/BRepAlgo/BRepAlgo_BOP.cxx>

* BRepAlgoAPI is just a wrapper that passes arguments into BRepAlgo\_BOP, eventually calling BRepAlgo\_BOP::PerformInternal where the magic happens.
* why use a BOPAlgo\_PaveFiller as the input to this function? Looks like BOPAlgo\_PaveFiller has vertex-vertex and vertex-edge (and lots of other) methods for performing the algorithm. The PaveFiller input is used to setup the myContext and myDS variables.
* * myContext doesn't show up in all the numbered PaveFiller files in this directory (it shows up in some, but not all)
* * myDS shows up in the numbered files in the directory, so maybe myDS is what's getting used by PaveFiller somehow?
* * BOPAlgo\_BOP::PerformInternal is called by Perform, but Perform is actually defined in BOPAlgo\_Builder because BOPAlgo\_BOP is a subclass of BOPAlgo\_Builder. It is BOPAlgo\_Builder::Perform that uses PaveFiller and calls PaveFiller::Perform.
* BOPAlgo\_BOP::BuildShape calls BuildRC() which makes clever calls to an instance of BRep\_Builder::Add() based on the current shapes. This function (BuildRC) is called in all situations for InternalPerform().

The method is as follows:

* (BOPAlgo\_Builder::Perform has already called PaveFiller perform things)
* BOPAlgo\_PaveFiller::PDS()
* BOPAlgo\_BOP::CheckData()
* BOPAlgo\_BOP::Prepare()
* BOPAlgo\_BOP::FillImagesVertices()
* BOPAlgo\_Builder::BuildResult(TopAbs\_VERTEX)
* BOPAlgo\_BOP::FillImagesEdges()
* BOPAlgo\_Builder::BuildResult(TopAbs\_EDGE)
* if BOPAlgo\_SECTION, then:
* * BOPAlgo\_BOP::BuildSection()
* * BOPAlgo\_BOP::PrepareHistory()
* * BOPAlgo\_BOP::PostTreat()
* * quit algorithm
* next handle wires:
* * BOPAlgo\_BOP::FillImagesContainers(TopAbs\_WIRE)
* * BOPAlgo\_Builder::BuildResult(TopAbs\_WIRE)
* next handle faces:
* * BOPAlgo\_BOP::FillImagesFaces()
* * BOPAlgo\_Builder::BuildResult(TopAbs\_FACE)
* next handle shells:
* * BOPAlgo\_BOP::FillImagesContainers(TopAbs\_SHELL)
* * BOPAlgo\_Builder::BuildResult(TopAbs\_SHELL)
* next handle solids:
* * BOPAlgo\_BOP::FillImagesSolids()
* * BOPAlgo\_Builder::BuildResult(TopAbs\_SOLID)
* next handle composite solids:
* * BOPAlgo\_BOP::FillImagesContainers(TopAbs\_COMPSOLID)
* * BOPAlgo\_Builder::BuildResult(TopAbs\_COMPSOLID)
* next handle compounds:
* * BOPAlgo\_BOP::FillImagesCompounds()
* * BOPAlgo\_Builder::BuildResult(TopAbs\_COMPOUND)
* BOPAlgo\_BOP::BuildShape() which calls BuildRC(), and in the case of BOPAlgo\_FUSE it will also call BuildSolid()
* BOPAlgo\_BOP::PrepareHistory()
* BOPAlgo\_BOP::PostTreat()

The BOPAlgo\_Builder::BuildResult method is [defined in BOPAlgo\_Builder\_1.cxx](https://github.com/tpaviot/oce/tree/master/src/BOPAlgo/BOPAlgo_Builder_1.cxx). It seems to just add shapes to a BRep\_Builder object.

<div id="BuildShape" />
## BuildShape

PerformInternal is basically the same in these two files, why?

* <https://github.com/tpaviot/oce/tree/master/src/BOPAlgo/BOPAlgo_Builder.cxx>
* <https://github.com/tpaviot/oce/tree/master/src/BOPAlgo/BOPAlgo_BOP.cxx>

A few differences...

* BOPAlgo\_BOP::PerformInternal has a call to BuildShape() that BOPAlgo\_Builder lacks

PaveFiller is where the really-really-real magic happens? PaveFiller calls the vertex-edge, vertex-vertex, edge-edge, and other object-object functions (often involving something about interference).

Depth and relevancy based tree of function calls:

* BOPAlgo\_BOP::PerformInternal (entry point, except for BRepAlgoAPI wrapper stuff)
* BOPAlgo\_BOP::BuildShape
* BOPAlgo\_BOP::BuildRC
* BOPAlgo\_BOP::BuildSolid (for BOPAlgo\_FUSE only) (this is the only one that uses the PaveFiller myContext thing, passed into the "aSB" variable (BOPAlgo\_BuilderSolid))
* BOPAlgo\_BuilderSolid::Perform (after SetContext and SetShape from BOPAlgo\_BOP::BuildSolid of course). SetShapes() passes a list of shapes, so Perform is operating on these shapes. But also, Areas() returns a list of shapes in a few moments.
* back in BOPAlgo\_BOP::BuildSolid after BOPAlgo\_BuilderSolid::Perform there is a call to BuilderSolid's Areas() then it iterates over those TopoDS\_Shape objects and adds them to the "aBB" object (BRep\_Builder instance). Note that the "aBB" (BRep\_Builder instance) object is modifying "aRC" which gets assigned to "myShape" (just like all the other paths, they all lead to "aRC", "myRC", and especially "myShape").
* back in BOPAlgo\_BOP::BuildSolid, myShape is finally set to the end result

Obvious next functions to read:

* BRep\_Builder::Add (what is it actually doing?)
* BOPAlgo\_BuilderSolid::Perform

<div id="PaveFiller" />
## PaveFiller

A description of paves and pave blocks can be found in [General fuse algorithm, partition algorithm, and the boolean operations algorithm](http://docs.salome-platform.org/salome_7_3_0/gui/GEOM/SALOME_BOA_PA.pdf).

The result of interferences of the type Vertex/Edge, Edge/Edge, Edge/Face in a number of cases is a vertex (new or old) lying on the edge. The result of interferences of the type Face/Face in a number of cases is one or more intersection curves. These curves go through the vertices lying on the faces.

A pave (PV) is a data structure that contains a vertex from a curve and the parameter of the 3D point of the vertex on the curve. The curve can be a 2D or 3D curve. Two paves (PV1, PV2) on the same curve can be compared using the parameter value (t1, t2) such that PV1 > PV2 if t1 > t2.

"The usage of paves allows making the difference between the one vertex V shared between arbitrary number of edes E1, E2, ... Ei. The usage of paves allows to bind the vertex to the curve (or any structure that contains a curve: edge, intersection curve)."

A pave block is a set of paves that can be sorted by the parameter value (t). A pave block only contains paves based on the same curve. A pave block is a part of the object (edge, intersection curve) between neighboring paves. Any finite source edge E has the one bounding pave block that contains two paves.

Each of the tolerance spheres of a vertex can reduce the parametric range of the pave block to \[t1S, t2S\]. The rane \[t1S, t2S\] is the "shrunk range" of the pave block. The shrunk range of the pave block is the part of 3D curve that can interfere with other shapes.

Common blocks (common parts) can be produced by the interferences between Edge/Edge and Edge/Face. In the case of Edge/Edge interference, the common parts are pave blocks having different edges as a base. If the set of pave blocks have the same bounding vertices and they geometrically coincide, the pave blocks form common block CB. In the case of Edge/Face interference the common parts are pave block lying on a face(s). If the pave blocks geometrically coincide with a face Fj, the pave block form common block CB.

In the general case, a common block CB contains (1) pave blocks (all of them? some of them?), (2) a set of faces F (all of them? some of them?).

Interfering shapes can produce connexity chains. This includes interfering vertices. For a set of interfering vertices that form a connexity chain, each connexity chain can be used to create a new vertex. Interfering edges can have coincided pave blocks. Interfering faces can also produce connexity chains.

A connexity chain contains shapes that are Same Domain Shapes (same domain vertices, same domain edges, same domain faces).

Split edges: a set of pave blocks for the edge E is used to build split edges (Spi where i is incremented for each of the pave blocks).

Section edges: the set of pave blocks for the intersection curve C is used to build section edges (Sci where i is incremented for each of the pave blocks).

* pave: data structure that contains a vertex from a curve and the parameter of the 3D point of the vertex on the curve
* pave block: set of paves
* what is a pave filler?

# dealing with legacy code

* use clang/clang++ and llvm opt to generate graphviz dot files of the call graph, then calculate the most popular functions for pruning the graph or begin clustering
* stack tracing
* logging
* comment out chunks of code, compile, run a routine again
* DRAWEXE
* remove unnecessary chunks of code

## callgraphs

[opencascade callgraphs](http://diyhpl.us/~bryan/irc/opencascade/callgraphs.tar.xz) (6 MB tarbomb, 2 json files) based on <https://github.com/tpaviot/oce> commit 9a97b1638c48e80d73c791a563cf5af8ad10096b (2014-05-09).

## largest files

* [AppCont/AppCont\_ContMatrices\_4.cxx](https://github.com/tpaviot/oce/tree/master/src/AppCont/AppCont_ContMatrices_4.cxx)
* [RWStepAP214/RWStepAP214\_ReadWriteModule.cxx](https://github.com/tpaviot/oce/tree/master/src/RWStepAP214/RWStepAP214_ReadWriteModule.cxx)
* [AdvApp2Var/AdvApp2Var\_Data\_2.cxx](https://github.com/tpaviot/oce/tree/master/src/AdvApp2Var/AdvApp2Var_Data_2.cxx)
* [AdvApp2Var/AdvApp2Var\_MathBase.cxx](https://github.com/tpaviot/oce/tree/master/src/AdvApp2Var/AdvApp2Var_MathBase.cxx)
* [AdvApp2Var/AdvApp2Var\_ApproxF2var.cxx](https://github.com/tpaviot/oce/tree/master/src/AdvApp2Var/AdvApp2Var_ApproxF2var.cxx)
* [AdvApp2Var/AdvApp2Var\_Data\_4.cxx](https://github.com/tpaviot/oce/tree/master/src/AdvApp2Var/AdvApp2Var_Data_4.cxx)
* [AdvApp2Var/AdvApp2Var\_Data\_5.cxx](https://github.com/tpaviot/oce/tree/master/src/AdvApp2Var/AdvApp2Var_Data_5.cxx)
* [ViewerTest/ViewerTest\_ViewerCommands.cxx](https://github.com/tpaviot/oce/tree/master/src/ViewerTest/ViewerTest_ViewerCommands.cxx)
* [AppCont/AppCont\_ContMatrices\_2.cxx](https://github.com/tpaviot/oce/tree/master/src/AppCont/AppCont_ContMatrices_2.cxx)
* [RWStepAP214/RWStepAP214\_GeneralModule.cxx](https://github.com/tpaviot/oce/tree/master/src/RWStepAP214/RWStepAP214_GeneralModule.cxx)
* [AdvApp2Var/AdvApp2Var\_Data\_6.cxx](https://github.com/tpaviot/oce/tree/master/src/AdvApp2Var/AdvApp2Var_Data_6.cxx)
* [AdvApp2Var/AdvApp2Var\_Data\_7.cxx](https://github.com/tpaviot/oce/tree/master/src/AdvApp2Var/AdvApp2Var_Data_7.cxx)
* [ViewerTest/ViewerTest\_ObjectCommands.cxx](https://github.com/tpaviot/oce/tree/master/src/ViewerTest/ViewerTest_ObjectCommands.cxx)
* [QABugs/QABugs\_11.cxx](https://github.com/tpaviot/oce/tree/master/src/QABugs/QABugs_11.cxx)
* [IntTools/IntTools\_FaceFace.cxx](https://github.com/tpaviot/oce/tree/master/src/IntTools/IntTools_FaceFace.cxx)
* [ChFi3d/ChFi3d\_Builder\_0.cxx](https://github.com/tpaviot/oce/tree/master/src/ChFi3d/ChFi3d_Builder_0.cxx)
* [BRepBuilderAPI/BRepBuilderAPI\_Sewing.cxx](https://github.com/tpaviot/oce/tree/master/src/BRepBuilderAPI/BRepBuilderAPI_Sewing.cxx)
* [math/math\_Kronrod.cxx](https://github.com/tpaviot/oce/tree/master/src/math/math_Kronrod.cxx)
* [ChFi3d/ChFi3d\_Builder\_C1.cxx](https://github.com/tpaviot/oce/tree/master/src/ChFi3d/ChFi3d_Builder_C1.cxx)
* [AppCont/AppCont\_ContMatrices\_1.cxx](https://github.com/tpaviot/oce/tree/master/src/AppCont/AppCont_ContMatrices_1.cxx)
* [IntPolyh/IntPolyh\_MaillageAffinage.cxx](https://github.com/tpaviot/oce/tree/master/src/IntPolyh/IntPolyh_MaillageAffinage.cxx)
* [Visual3d/Visual3d\_View.cxx](https://github.com/tpaviot/oce/tree/master/src/Visual3d/Visual3d_View.cxx)
* [IntPatch/IntPatch\_PrmPrmIntersection.cxx](https://github.com/tpaviot/oce/tree/master/src/IntPatch/IntPatch_PrmPrmIntersection.cxx)
* [AppCont/AppCont\_ContMatrices.cxx](https://github.com/tpaviot/oce/tree/master/src/AppCont/AppCont_ContMatrices.cxx)
* [IFSelect/IFSelect\_WorkSession.cxx](https://github.com/tpaviot/oce/tree/master/src/IFSelect/IFSelect_WorkSession.cxx)
* [HLRBRep/HLRBRep\_PolyAlgo.cxx](https://github.com/tpaviot/oce/tree/master/src/HLRBRep/HLRBRep_PolyAlgo.cxx)
* [ViewerTest/ViewerTest.cxx](https://github.com/tpaviot/oce/tree/master/src/ViewerTest/ViewerTest.cxx)
* [ShapeFix/ShapeFix\_Wire.cxx](https://github.com/tpaviot/oce/tree/master/src/ShapeFix/ShapeFix_Wire.cxx)
* [BRepOffset/BRepOffset\_Tool.cxx](https://github.com/tpaviot/oce/tree/master/src/BRepOffset/BRepOffset_Tool.cxx)
* [TopOpeBRepDS/TopOpeBRepDS\_EXPORT.cxx](https://github.com/tpaviot/oce/tree/master/src/TopOpeBRepDS/TopOpeBRepDS_EXPORT.cxx)
* [Quantity/Quantity\_Color.cxx](https://github.com/tpaviot/oce/tree/master/src/Quantity/Quantity_Color.cxx)
* [BSplCLib/BSplCLib.cxx](https://github.com/tpaviot/oce/tree/master/src/BSplCLib/BSplCLib.cxx)
* [BRepOffset/BRepOffset\_MakeOffset.cxx](https://github.com/tpaviot/oce/tree/master/src/BRepOffset/BRepOffset_MakeOffset.cxx)
* [AppCont/AppCont\_ContMatrices\_3.cxx](https://github.com/tpaviot/oce/tree/master/src/AppCont/AppCont_ContMatrices_3.cxx)
* [IFSelect/IFSelect\_Functions.cxx](https://github.com/tpaviot/oce/tree/master/src/IFSelect/IFSelect_Functions.cxx)
* [ChFi3d/ChFi3d\_Builder\_CnCrn.cxx](https://github.com/tpaviot/oce/tree/master/src/ChFi3d/ChFi3d_Builder_CnCrn.cxx)
* [V3d/V3d\_View.cxx](https://github.com/tpaviot/oce/tree/master/src/V3d/V3d_View.cxx)
* [STEPCAFControl/STEPCAFControl\_Writer.cxx](https://github.com/tpaviot/oce/tree/master/src/STEPCAFControl/STEPCAFControl_Writer.cxx)
* [ShapeFix/ShapeFix\_ComposeShell.cxx](https://github.com/tpaviot/oce/tree/master/src/ShapeFix/ShapeFix_ComposeShell.cxx)
* [ChFi3d/ChFi3d\_Builder\_2.cxx](https://github.com/tpaviot/oce/tree/master/src/ChFi3d/ChFi3d_Builder_2.cxx)
* [BSplSLib/BSplSLib.cxx](https://github.com/tpaviot/oce/tree/master/src/BSplSLib/BSplSLib.cxx)
* [BRepFill/BRepFill\_Evolved.cxx](https://github.com/tpaviot/oce/tree/master/src/BRepFill/BRepFill_Evolved.cxx)
* [DDataStd/DDataStd\_BasicCommands.cxx](https://github.com/tpaviot/oce/tree/master/src/DDataStd/DDataStd_BasicCommands.cxx)
* [BRepFill/BRepFill\_Sweep.cxx](https://github.com/tpaviot/oce/tree/master/src/BRepFill/BRepFill_Sweep.cxx)
* [STEPCAFControl/STEPCAFControl\_Reader.cxx](https://github.com/tpaviot/oce/tree/master/src/STEPCAFControl/STEPCAFControl_Reader.cxx)
* [ViewerTest/ViewerTest\_RelationCommands.cxx](https://github.com/tpaviot/oce/tree/master/src/ViewerTest/ViewerTest_RelationCommands.cxx)
* [ShapeFix/ShapeFix\_Face.cxx](https://github.com/tpaviot/oce/tree/master/src/ShapeFix/ShapeFix_Face.cxx)
* [PLib/PLib.cxx](https://github.com/tpaviot/oce/tree/master/src/PLib/PLib.cxx)
* [AIS/AIS\_InteractiveContext.cxx](https://github.com/tpaviot/oce/tree/master/src/AIS/AIS_InteractiveContext.cxx)
* [AdvApp2Var/AdvApp2Var\_SysBase.cxx](https://github.com/tpaviot/oce/tree/master/src/AdvApp2Var/AdvApp2Var_SysBase.cxx)
* [GeomPlate/GeomPlate\_BuildPlateSurface.cxx](https://github.com/tpaviot/oce/tree/master/src/GeomPlate/GeomPlate_BuildPlateSurface.cxx)
* [OpenGl/OpenGl\_Workspace\_Raytrace.cxx](https://github.com/tpaviot/oce/tree/master/src/OpenGl/OpenGl_Workspace_Raytrace.cxx)
* [math/math.cxx](https://github.com/tpaviot/oce/tree/master/src/math/math.cxx)
* [IntTools/IntTools\_BeanFaceIntersector.cxx](https://github.com/tpaviot/oce/tree/master/src/IntTools/IntTools_BeanFaceIntersector.cxx)
* [Graphic3d/Graphic3d\_Structure.cxx](https://github.com/tpaviot/oce/tree/master/src/Graphic3d/Graphic3d_Structure.cxx)
* [BRepMesh/BRepMesh\_Delaun.cxx](https://github.com/tpaviot/oce/tree/master/src/BRepMesh/BRepMesh_Delaun.cxx)
* [BiTgte/BiTgte\_Blend.cxx](https://github.com/tpaviot/oce/tree/master/src/BiTgte/BiTgte_Blend.cxx)
* [ShapeFix/ShapeFix\_IntersectionTool.cxx](https://github.com/tpaviot/oce/tree/master/src/ShapeFix/ShapeFix_IntersectionTool.cxx)
* [HLRBRep/HLRBRep\_Data.cxx](https://github.com/tpaviot/oce/tree/master/src/HLRBRep/HLRBRep_Data.cxx)
* [DNaming/DNaming\_ModelingCommands.cxx](https://github.com/tpaviot/oce/tree/master/src/DNaming/DNaming_ModelingCommands.cxx)
* [BRepFill/BRepFill\_TrimShellCorner.cxx](https://github.com/tpaviot/oce/tree/master/src/BRepFill/BRepFill_TrimShellCorner.cxx)
* [BRepFeat/BRepFeat\_RibSlot.cxx](https://github.com/tpaviot/oce/tree/master/src/BRepFeat/BRepFeat_RibSlot.cxx)
* [AdvApp2Var/AdvApp2Var\_Data\_1.cxx](https://github.com/tpaviot/oce/tree/master/src/AdvApp2Var/AdvApp2Var_Data_1.cxx)
* [TopOpeBRepBuild/TopOpeBRepBuild\_KPart.cxx](https://github.com/tpaviot/oce/tree/master/src/TopOpeBRepBuild/TopOpeBRepBuild_KPart.cxx)
* [StepData/StepData\_StepReaderData.cxx](https://github.com/tpaviot/oce/tree/master/src/StepData/StepData_StepReaderData.cxx)
* [STEPControl/STEPControl\_ActorRead.cxx](https://github.com/tpaviot/oce/tree/master/src/STEPControl/STEPControl_ActorRead.cxx)
* [IntPatch/IntPatch\_ImpPrmIntersection.cxx](https://github.com/tpaviot/oce/tree/master/src/IntPatch/IntPatch_ImpPrmIntersection.cxx)
* [IntAna/IntAna\_QuadQuadGeo.cxx](https://github.com/tpaviot/oce/tree/master/src/IntAna/IntAna_QuadQuadGeo.cxx)
* [GeomLib/GeomLib.cxx](https://github.com/tpaviot/oce/tree/master/src/GeomLib/GeomLib.cxx)
* [BRepFill/BRepFill\_OffsetWire.cxx](https://github.com/tpaviot/oce/tree/master/src/BRepFill/BRepFill_OffsetWire.cxx)
* [TopOpeBRepBuild/TopOpeBRepBuild\_BuilderON.cxx](https://github.com/tpaviot/oce/tree/master/src/TopOpeBRepBuild/TopOpeBRepBuild_BuilderON.cxx)
* [TNaming/TNaming\_Naming.cxx](https://github.com/tpaviot/oce/tree/master/src/TNaming/TNaming_Naming.cxx)
* [TNaming/TNaming\_Name.cxx](https://github.com/tpaviot/oce/tree/master/src/TNaming/TNaming_Name.cxx)
* [StepAP214/StepAP214\_Protocol.cxx](https://github.com/tpaviot/oce/tree/master/src/StepAP214/StepAP214_Protocol.cxx)
* [ShapeAnalysis/ShapeAnalysis\_Wire.cxx](https://github.com/tpaviot/oce/tree/master/src/ShapeAnalysis/ShapeAnalysis_Wire.cxx)
* [IntCurve/IntCurve\_IntConicConic\_1.cxx](https://github.com/tpaviot/oce/tree/master/src/IntCurve/IntCurve_IntConicConic_1.cxx)
* [GeomInt/GeomInt\_IntSS\_1.cxx](https://github.com/tpaviot/oce/tree/master/src/GeomInt/GeomInt_IntSS_1.cxx)
* [ChFi3d/ChFi3d\_FilBuilder.cxx](https://github.com/tpaviot/oce/tree/master/src/ChFi3d/ChFi3d_FilBuilder.cxx)
* [ChFi3d/ChFi3d\_ChBuilder.cxx](https://github.com/tpaviot/oce/tree/master/src/ChFi3d/ChFi3d_ChBuilder.cxx)
* [ChFi3d/ChFi3d\_Builder\_6.cxx](https://github.com/tpaviot/oce/tree/master/src/ChFi3d/ChFi3d_Builder_6.cxx)
* [StepAP209/StepAP209\_Construct.cxx](https://github.com/tpaviot/oce/tree/master/src/StepAP209/StepAP209_Construct.cxx)
* [QABugs/QABugs\_19.cxx](https://github.com/tpaviot/oce/tree/master/src/QABugs/QABugs_19.cxx)
* [OSD/OSD\_File.cxx](https://github.com/tpaviot/oce/tree/master/src/OSD/OSD_File.cxx)
* [Geom/Geom\_BSplineSurface\_1.cxx](https://github.com/tpaviot/oce/tree/master/src/Geom/Geom_BSplineSurface_1.cxx)
* [Geom/Geom\_BezierSurface.cxx](https://github.com/tpaviot/oce/tree/master/src/Geom/Geom_BezierSurface.cxx)
* [Draw/Draw\_Window.cxx](https://github.com/tpaviot/oce/tree/master/src/Draw/Draw_Window.cxx)
* [Draft/Draft\_Modification\_1.cxx](https://github.com/tpaviot/oce/tree/master/src/Draft/Draft_Modification_1.cxx)
* [TPrsStd/TPrsStd\_ConstraintTools.cxx](https://github.com/tpaviot/oce/tree/master/src/TPrsStd/TPrsStd_ConstraintTools.cxx)
* [TopOpeBRepBuild/TopOpeBRepBuild\_Builder1.cxx](https://github.com/tpaviot/oce/tree/master/src/TopOpeBRepBuild/TopOpeBRepBuild_Builder1.cxx)
* [NIS/NIS\_Triangulated.cxx](https://github.com/tpaviot/oce/tree/master/src/NIS/NIS_Triangulated.cxx)
* [Geom/Geom\_OffsetSurface.cxx](https://github.com/tpaviot/oce/tree/master/src/Geom/Geom_OffsetSurface.cxx)
* [BRepFill/BRepFill\_CompatibleWires.cxx](https://github.com/tpaviot/oce/tree/master/src/BRepFill/BRepFill_CompatibleWires.cxx)
* [BOPAlgo/BOPAlgo\_PaveFiller\_6.cxx](https://github.com/tpaviot/oce/tree/master/src/BOPAlgo/BOPAlgo_PaveFiller_6.cxx)
* [TopOpeBRepDS/TopOpeBRepDS\_BuildTool.cxx](https://github.com/tpaviot/oce/tree/master/src/TopOpeBRepDS/TopOpeBRepDS_BuildTool.cxx)
* [TopOpeBRepBuild/TopOpeBRepBuild\_GridSS.cxx](https://github.com/tpaviot/oce/tree/master/src/TopOpeBRepBuild/TopOpeBRepBuild_GridSS.cxx)
* [STEPControl/STEPControl\_ActorWrite.cxx](https://github.com/tpaviot/oce/tree/master/src/STEPControl/STEPControl_ActorWrite.cxx)
* [ShapeCustom/ShapeCustom\_BSplineRestriction.cxx](https://github.com/tpaviot/oce/tree/master/src/ShapeCustom/ShapeCustom_BSplineRestriction.cxx)
* [QABugs/QABugs\_3.cxx](https://github.com/tpaviot/oce/tree/master/src/QABugs/QABugs_3.cxx)
* [QABugs/QABugs\_17.cxx](https://github.com/tpaviot/oce/tree/master/src/QABugs/QABugs_17.cxx)
* [IntPatch/IntPatch\_LineConstructor.cxx](https://github.com/tpaviot/oce/tree/master/src/IntPatch/IntPatch_LineConstructor.cxx)

# questions

## is a 2d circle represented as a bezier curve spline in opencascade?

## if you extrude a circle, then fuse with a nurbs surface, what happens to the original circle object or the result of the circle-extrusion?

## where is the source code for curve-curve, curve-surface, and surface-surface nurbs intersection?

partial answer: <https://github.com/tpaviot/oce/blob/master/src/BRepAlgo/BRepAlgo_BooleanOperation.cxx>

also see:

* <http://dev.opencascade.org/doc/overview/html/occt_user_guides__modeling_algos.html>
* <http://dev.opencascade.org/doc/overview/html/occt_user_guides__boolean_operations.html>

<div id="packages" />
# packages

basic math:

* math - random numbers, Gauss, GaussLeastSquare, SVD, DirectPolynomialRoots, FunctionRoots, BissecNewton, FunctionRoot, NewtonFunctionRoot, BracketedRoot, FunctionSetRoot, NewtonFunctionSetRoot, BracketMinimum, BrentMinimum, Powell, FRPR, BFGS, NewtonMinimum, Jacobi, GaussSingleIntegration, GaussMultipleIntegration, GaussSetIntegration, RealRandom, FunctionSample, FunctionAllRoots, Householder, Crout, Uzawa, TrigonometricFunctionRoots, KronrodSingleIntegration (Kronrod method implementation), ComputeGaussPointsAndWeights, ComputeKronrodPointsAndWeights, QuickSortOfValueAndWeight, OrderedGaussPointsAndWeights, etc.
* PLib - polynomial functions library. JacobiPolynomial, HermitJacobi, DoubleJacobiPolynomial, RationalDerivative, binomials, EvalLagrange, JacobiParameters.
* Expr - data structure of any expression, relation or function used in mathematics. Describes the assignment of variables. Standard mathematical functions are implemented such as trigonometrics, hyperbolics, and log functions. ArcCosine, ArcSine, ArcTangent, ArgCosh, ArgSinh, ArgTanh, Cosh, Cosine, Exponential, LogOfe, LogOf10, Sign, Sine, Sinh, Square, SquareRoot, Tangent, Tanh, UnaryFunction, UnaryMinus, BinaryFunction, Difference, Division, PolyExpression, Different, Equal, GreaterThan, LessThan, etc.
* ExprIntrp - yacc/lex files, describes an interpreter for GeneralExpressions, GeneralFunctions, and GeneralRelations defined in package Expr.

basic geometry:

* gp - Geometric Processor; implementation of entities for algebraic calculations such as "XYZ" coordinates, "Mat" matrix; for basic analytic geometry such as transformations, point, vector, line, plane, axis placement, conics, and elementary surfaces. These entities are defined in 2d and 3d space. Pnt, Vec, Dir, Ax1, Ax2, Ax3, Lin, Circ, Elips, Hypr, Parab, Pln, Cylinder, Sphere, Torus, Cone, XY, Mat2d, Trsf2d, GTrsf2d, Pnt2d, Vec2d, Dir2d, Ax2d, Ax22d, Lin2d, Circ2d, Elips2d, Hypr2d, Parab2d, etc.
* Geom - definition of the geometric objects such as point, vector, axis placement, curves, surfaces, and the description of geometric transformations available for these objects. All of these entities are defined in 3D space. This package enables creating and modifying geometric objects. This package uses the package gp (Geometric Processor) which describes non-persistent objects for algebraic calculus and basic analytic geometry. The purpose of this package is to create persistent geometric objects and to read geometric information about these objects. Complexes geometric algorithms are not described in this package. At construction time, elementary verifications are done to verify that the objects are coherent, but some verifications which require complex algorithms (for example, to check that a curve has not null length or does not self-intersect) must be done before the construction of the geometric objects.
* Geom2d - definition of the geometric objects such as point, vector, axis placement, curves and the description of the geometric transformations available for these objects. All of these entities are defined in 2D space. This package enables creating and modifying geometric objects. Uses gp (Geometric Processor). See also the Geom package.
* Geom2dAdaptor - geometric definition of 2d curves compatible with the Adaptor package templates.
* GeomAbs - enumerations for geometry types: CurveType, SurfaceType, Shape, CurveForm, SurfaceForm, BSplKnotDistribution enumeration to describe the repartition of set of knots, UVSense enumeration to describe the orientation of the parametric surface.
* GeomAdaptor - geometric definition of curve and surface necessary to use algorithms
* gce - make things from gp, like: dir2d, lin2d, circ2d, hypr2d, elips2d, parab2d, translation transformation, symmetry transformation, rotation transformation, scaling transformation, scalar product between two vectors, cross product, dot cross, line, circle, hyperbola, ellipse, parabola, plane, cylinder, cone.
* GCE2d - make things from a Geom2d: line, circle, hyperbola, ellipse, parabola, segment of line, arc of circle, arc of ellipse, arc of parabola, arc of hyperbola, translation transformation, symmetry/mirror transformation, rotation transformation, scaling transformation.
* GeomTools - utilities for goemetry, like SurfaceSet, CurveSet, Curve2dSet which are tools used for dumping, writing and reading. Methods to dump, write, read curves and surfaces.
* GC - Constructions of 3d geometrical elements from Geom. Constructions of planes from Geom. Construction of surfaces from Geom. Constructions of transformation from Geom.
* Adaptor2d - helper for reusable geometric algorithms that can be used on curves and surfaces. Type compatibility. Especially use with Geom and Geom2d.
* Adaptor3d - helper for reusable geometric algorithms that can be used on curves and surfaces, like Curve2d, Curve, Surface. Especially use with Geom and Geom2d.
* Draft - Returns the draft angle of the face F using the direction Direction, the method is valid for plane faces, cylindrical or conic faces, when the direction of the axis of the surface is colinear with the direction. Otherwise, the exception DomainError is raised.
* Geom2dConvert - algorithms to convert between equivalent geometric entities from package Geom2d. It can be used to obtain the B-spline representation of bounded curves; to split a B-spline curve into several B-spline curves with some constraints of continuity; to convert a B-spline curve into several Bezier curves or surfaces. All the geometric entities used in this package are bounded.
* * Generating the Bezier Points of B-spline curves and surfaces (Wolfgang Bohm) CAGD volume 13 number 6 november 1981
* * On NURBS: A Survey  (Leslie Piegl) IEEE Computer Graphics and Application January 1991
* * Curve and surface construction using rational B-splines (Leslie Piegl and Wayne Tiller) CAD Volume 19 number 9 November 1997
* * A survey of curve and surface methods in CAGD (Wolfgang BOHM) CAGD 1 1984

curves and surfaces:

* Law - 1d functions, like BSpline, Interpolate, Constant, Linear, BSpFunc, Interpol, Composite, BSplineKnotSplitting, MixBnd, MixTgt, Scale, ScaleCub, etc.
* BSplCLib - bspline curve library. Methods to process knots and multiplicities. Multi-dimensional spline methods, particularly BSpline methods where the poles have an arbitrary number of dimensions, these methods are divided into two groups: (1) global methods modifying the whole set of poles. The poles are described by an array of reals and a dimension, like for inserting knots. (2) Local methods computing points and derivatives. The poles are described by a pointer on a local array of reals and a dimension. The local array is modified. Also, 2d and 3d spline curves methods, both rational and not ratoinal curves. Note that the bspline surface methods found in the BSplSLib package uses the same structure and relies on BSplCLib. Uses math, gp and GeomAbs.
* * A survey of curves and surfaces methods in CADG Wolfgang BOHM CADG 1 (1984)
* * On de Boor-like algorithms and blossoming Wolfgang BOEHM cagd 5 (1988) (typo?)
* * Blossoming and knot insertion algorithms for B-spline curves (Ronald N. GOLDMAN)
* * Modelisation des surfaces en CAO, Henri GIAUME Peugeot SA
* * Curves and Surfaces for Computer Aided Geometric Design, a practical guide (Gerald Farin)
* BSplSLib - bspline surface library. See also BSplCLib.
* Contap - contour generation, arc functions, surface tool, topology tool, surface function, contour tool generator, etc.
* Convert - algorithms to convert the following into a BSpline curve or surface: (1) a bounded curve based on an elementary 2D curve (line, circle or conic) from the gp package; (2) a bounded surface based on an elementary surface (cylinder, cone, sphere or torus) from the gp package; (3) a series of adjacent 2D or 3D Bezier curves defined by their poles. These algorithms compute the data needed to define the resulting BSpline curve or surface. This elementary data (degrees, periodic characteristics, poles and weights, knots and multiplicities) may then be used directly in an algorithm, or can be used to construct the curve or the surface by calling the appropriate constructor provided by the classes Geom2d\_BSplineCurve, Geom\_BSplineCurve or Geom\_BSplineSurface.
* CPnts - definition of geometric algorithms to compute characteristic points on parametrized curves in 3d or 2d space. This package defines the external geometric entities, with their requirements, used in the algorithms.
* CSLib - implements functions for basis geometric computation on curves and surfaces. The tolerance criterions used in this package are Resolution from package gp and RealEpsilon from class Real of package Standard. (JCV Decembre 1991)
* ElCLib - Elementary curves library; geometric computations on elementary curves such as conics and lines in 2D and 3D space. This includes: calculation of a point or derived vector on a 2D or 3D curve where the curve is provided by the gp package or defined in reference form (as in the gp package), and the point is defined by a parameter, also including various elementary computations which allow you to position parameterized values within the period of a curve. If the curves provided by the gp package are not explicitly parameterized, they still have an implicit parameterization, analogous to that which they infer for the equivalent Geom or Geom2d curves.
* ElSLib - Elementary surfaces library; geometric computations on elementary surfaces. This includes: calculation of a point or derived vector on a surface where the surface is provided by the gp package or defined in canonical form (as in the gp package) and the point is definied with a parameter, also including evaluation of the parameters corresponding to a point on an elementary surface from gp, also including calculation of isoparametric curves on an elementary surface defined in canonical form (as in the gp package).
* Extrema - calculate the distance between points, curves and surfaces. In the general case, the algorithm to find the distances is a minimization algorithm of a function of variables: F(X). It is stopped when for X1=X+Dx, F(X) and F(X1) are the same. The value of Dx can be calculated for all the algorithms. Generic classes for point-curve extremas, point-surface extremas, curve-curve extremas, curve-surface extremas, surface-surface extremas, lots of others.
* FairCurve - make a "FairCurve" by no linear optimization. Batten. Curve with MinimalVariation of curvature or "MVC". To deal with the different results in the computation of curvatures. FairCurve\_InfiniteSliding describes the case where sliding is infinite, and, consequently, computation stops. The solution is to use an imposed sliding value. FairCurve\_NullHeight describes the case where no matter is left at one of the ends of the curve, and as a result, computation stops. The solution is to change (increase or reduce) the slope value by increasing or decreasing it.
* GCPnts - geometric algorithms used to compute characteristic points on parameterized curves. They are high level algorithms based on the low level algorithms in CPnts, including: AbscissaPoint, UniformAbscissa, UniformDeflection, QuasiUniformDeflection, QuasiUniformAbscissa, TangentialDeflection.
* Geom2dAPI - project point on curve, extrema curve curve (distance between points and curves, and distance between curves and curves), PointsToBSpline (evaluate a curve passing through an array of points), Interpolate, InterCurveCurve (algorithm to evaluate an intersection between two 2d curves).
* GeomAPI - algorithms to evaluate the distance between points, curves and surfaces; algorithms to evaluate a curve or a surface passing through an array of points; algorithms to intersect two surfaces and to intersect a curve and a surface; algorithms to switch between 3d and 2d curves (To2d, To3d).
* GeomConvert - convert classical Geom curves into BSpline curves; segmenting BSpline curves, particularly at knots; converting classical Geom surfaces into BSpline surfaces;
* * Generating the Bezier Points of B-spline curves and surfaces (Wolfgang Bohm) CAGD volume 13 number 6 november 1981
* * On NURBS: A Survey  (Leslie Piegl) IEEE Computer Graphics and Application January 1991
* * Curve and surface construction using rational B-splines (Leslie Piegl and Wayne Tiller) CAD Volume 19 number 9 November 1997
* * A survey of curve and surface methods in CAGD (Wolfgang BOHM) CAGD 1 1984
* LocalAnalysis - check the local continuity between two points situated on two curves or two surfaces
* GeomLib - Geom and Geom2d basic geometric entity computation library. Use Interpolate to compute the poles of a curve given some parameters, points to interpolate and boundary conditions in 3d. Use DenominatorMultiplier to get an evaluator for a function of 2 variables that will be used by CancelDenominatorDerivative in one direction. Use CheckBSplineCurve to check for end tangents, whether or not those are reversed regarding the third or n-3rd control. ExtendSurfByLength, AxeOfInertia, RemovePointsFromArray, DensifyArray1Ofreal, TensorialProduct, NormEstim, Inertia, etc.
* GeomLProp - compute the degree of continuity of a 3D curve built by concatenation of two other curves (or portions of curves) at their junction point.
* GeomProjLib - projection of a curve on a surface
* GProp - algorithms to compute the global properties of a set of points, a curve, a surface, a solid (non infinite region of space delimited with geometric entities), a compound geometric system (heterogenous composition of the previous entities). Global properties are: length, area, volume, centre of mass, axis of inertia, moments of inertia, radius of gyration. It also provides a class to compile the average point or line of a set of points.
* LProp - Given a curve and a parameter value, the following computations are available: point, derivatives, tangent, normal, curvature, center of curvature, locals curvature's extremas, points of inflection; Given a surface and 2 parameters the following computations are available: for each parameters (derivatives, tangent line, center of curvature), also point, normal line, maximum and minimum curvatures, principal directions of curvature, mean curvature, Gaussian curvature.
* Geom2dLProp - handles local properties of curves and surfaces from the packages Geom and Geom2d, see package LProp
* LProp3d - handles local properties of curves and surfaces from the package Adaptor3d. This originates from BRepLProp being abstracted from BRep.
* ProjLib - projection of curves on a plane along a given direction. The result will be a 3D curve. Also, projections of curves on surfaces to compute the curve in the parameteric space. It is assumed that the curve is on the surface. Easiest cases: line, circle, ellipse, parabola, hyperbola on a plane; line, circle on cylinder; line, circle on cone. General case of: plane, cylinder, cone, sphere, torus; and a generic class to handle a curve from Adaptor3d on a Surface from Adaptor3d.
* ShapeConstruct - Algorithms for constructing new geometrical objects and topological shapes, like for: projecting curves on surface, adjusting curve to have given start and end points.
* Hermit - This is used to reparameterize rational bspline curves so that we can concatenate them later to build C1 curves. It builds and 1D-reparameterizing function starting from an Hermite interpolation and adding knots and modifying poles of the 1D BSpline obtained that way. The goal is to build a(u) so that if we consider a BSpline curve f(u) = N(u) / D(u) the function a(u)D(u) has value 1 at the umin and umax and has 0.0e0 derivative value a umin and umax. The details of the computation occuring in this package can be found by reading: "Etude sur la concatenation de NURBS en vue du balayage de surfaces" PFE n S85 Ensam Lille.

geometric bisecting:

* Bisector - bisecting line between two geometric elements (such as circles, lines or points), bisecting line between a point and a curve, bisecting line between two curves, bisecting line trimmed by a point.
* MAT - algorithm of bisecting locus
* MAT2d - computation of Bisector locus on a set of geometries from Geom2d
* BRepMAT2d - BRep bisection stuff, map/collection classes

geometric constraints and constraint solving:

* GccAna - create lines and circles from constraints, based on objects from gp; see also Geom2dGcc. Analytical algorithms, can only be used for geometries of lines and circles, both the input and output types are gp objects (qualified curves for tangency are provided by GccEnt); also maybe GccInt is used or it may be a typo for GccEnt.
* GccEnt - implementation of the qualified entities useful to create 2d entities with geometric constraints. The qualifier explains which subfamily of solutions we want to obtain. It uses the following law: the matter/the interior side is at the left of the line, if we go from the beginning to the end. The qualifiers are: (1) enclosing - the solution(s) must enclose the argument; (2) enclosed - the solution(s) must be enclosed in the argument; (3) outside - both the solution(s) and the argument must be outside to each other; (4) unqualified - the position is undefined, so give all the solutions. The use of a qualifier is always required if such subfamilies exist. For example, it is not used for a point. Note that the interior of a curve is defined as the left-hand side of the curve in relation to its orientation.
* GccGeo - implementation of analytic algorithms (using only non-persistent entities) used to create 2d lines or circles with geometric constraints.
* GccInt - implementation of algorithm needed by Gcc to use curves other than lines or circles. This package is also used for intersections and bisecting curves.
* GccIter - implementation of analytic algorithms (using only non-persistent entities) used to create 2d lines or circles with geometric constraints.
* Geom2dGcc - create lines and circles from constraints, based on objects from Geom2d; see also GccAna. Automatically selects an algorithm for the problem, inputs are Geom2d objects and the computed solutions are gp objects (qualified curves for tangency can be provided by Geom2dGcc). The Geom2dGcc package solves geometric constructions of lines and circles expressed by constraints such as tangency or parallelism, that is, a constraint expressed in geometric terms.

sweeps and filling:

* GeomFill - filling surface and sweep surfaces; Line, SectionGenerator, filling BezierCurves, filling BSplineCurves, SweepSectionGenerator for evaluating the sections of a sweep surface, ConstrainedFilling for filling a countour of 2, 3, or 4 curves with tangency constraints; other stuff.
* BRepFill - algorithm to build a face from either a set of edges defining the bounds of the face and some constraints the surface of the face has to satisfy, or a set of edges and points defining some constraints the support surface has to satisfy, or an initial surface to deform for satisfying the constraints, or a set of parameters to control the constraints. Compute a topological surface (a shell) using generating wires, where the face of the shell will be ruled surfaces through the wires, and the wires must have the same number of edges. Has sweeped, evolved, draft law, edge3d law, multiline tool, pipe, PipeShell, ShapwLaw, TrimEdgeTool, TrimShellCorner, TrimSurfaceTool. Other stuff. ApproxSeewing.
* BiTgte - create a filler rolling on an edge; curve on edge; curve on vertex; DataMapOfShapeBox

approximation:

* AdvApp2Var - algorithms to approximate a function of 2 variables that can be multidimensional, the result is a BSpline function with the required continuity. Only one 3D BSpline at the moment. Iso, Patch, Strip, SequenceOfNode, SequenceOfPatch, SequenceOfStrip. Iso is used to store constraints on a line U = Ui or V = Vj. Patch is used to store results on a domain. Strip is used as a set of constraints along a same type of Iso on the same level.
* AdvApprox - algorithms to approximate a function that can be multidimensional, the result is a BSpline function with the required continuity. Cutting, DichoCutting, PrefCutting, PrefAndRec.w
* Approx - algorithms approximating a set of points or curves with the possibility of dividing into one or many bezier curves. Also approximates a continuous function f(t) into one or many curves. Uses math, gp, GeomAbs, Geom, Geom2d, Adaptor3d, Adaptor2d, etc.
* ApproxInt - dunno, probably more approximation stuff? uses Approx.
* AppBlend - dunno, has a few classes like Approx, AppSurf, Debug, Line, SectionGenerator.
* AppCont - least square algorithm for approximating a set of continuous curves or a continuous surface. Also FittingCurve2d.
* AppDef - classes for approximating points in Bezier curves used by the AppParCurves package. The points of the same range for the approximation are organized in MultiPointConstraints. These MultiPointConstraints are organized in a MultiLine. The corresponding result of a MultiLine approximation is a MultiCurve (set of Bezier curves) which has the same structure as a MultiLine: the MultiCurve is a set of MultiPoint. A point of a MultiLine can have many significations: the approximation curve can go through this point or not, can have a given tangency, or can have a given curvature. Note that a CurvaturePoint is also a PassPoint and a TangencyPoint. A TangencyPoint is also a PassPoint.
* AppParCurves - parallel approximation in n curves, algorithms to approximate a MultiLine described by the tool MLineTool. The result of the approximation will be a MultiCurve (from AppDef?).
* BRepBlend - some surface approximation stuff, points on curves, dunno

* Blend - SurfRstFunction, SurfPointFuncInv, SurfCurvFuncInv, RstRstFunction, CurvPointFuncInv, DecrochStatus, etc.
* BlendFunc - compute blendings between two surfaces (constant radius, evolutive radius, ruled surface). Ruled, RuledInv, EvolRad, EvolRadInv, Corde, Chamfer, ChamfInv, ChAsym, ChAsymInv, Tensor, Knots, Mults, GetMinimalWeights, ComputeNormal, ComputeDNormal, etc.

bounding boxes:

* Bnd - bounding volumes, used to bound a shape to optimizing algorithms. If a point is outside the bounding volume of a shape it is also outside the shape. The contrary is not necessarily true. In 3d there is Box and BoundSortBox. In 2d there is Box2d and BoundSortBox2d. (bounding boxes?)
* BndLib - Package to compute the bounding boxes for elementary objects from gp in 2d and 3d. Functions to add a geometric primitive to a bounding box. Note that these functions work with gp objects, optionally limited by parameter values. Compute the bounding box for a curve in 2 dimensions. Compute the bounding box for a curve in 3 dimensions. Compute the bounding box of a surface. The surface is defined by a tool for the geometry and another tool for the topology (only the edges in 2 dimensions). etc.
* BRepBndLib - bounding boxes for curves and surfaces from BRepAdaptor. Functions to add a topological shape to a bounding box.

intersections:

* BRepApprox - algorithms for the approximation of intersection curves for BRep objects
* IntAna - compute the intersections between (1) natural quadrics when the result is a conic (QuadQuadGeo); (2) a natural quadric and a quadric defined by its coefficients (IntQuadQuad); (3) 3 Pln (Int3Pln); (4) a Line and a Torus (IntLinTorus); (5) a Conic from gp and a Quadric defined by its coefficients (IntConicQuad).
* IntAna2d - compute the intersection between two Geometric Processor (gp) types (Line, Circle, Ellipse, Parabola, and Hyperbola. One of these elements is known with his real type, the other one is known by an implicit quadratic equation (see class Conic). A particular case has been made for the intersection between two Lin2d, two Circ2d, a Lin2d and a Circ2d.
* IntCurve - compute the intersections between 2D curves, with domains. Use IntConicConic for an algorithm to intersect 2 conics from gp with domains. Use IntConicCurveGen for an algorithm to intersect a conic from gp, and a parameterized curve. The parameterized Curve can not be a Composite curve and can not be a conic. Use IntCurveCurveGen for an algorithm to intersect 2 curves. Use UserIntConicCurveGen for an algorithm to intersect a Conic from gp and a parameterized curve, either a composite curve or a conic.
* IntCurvesFace - compute the intersection points between a Face (a Shape) and a set of curves (the face (shape) is loaded, then for each curve is given to compute the intersection). Intersector (ShapeIntersector) can be used when the caller has to intersect more than one curve with the face (the shape). If there is only one curve, or if the face has no restrictions, some other algorithm can be called. See also the BRepIntCurveSurface package (for one curve and one shape) or the IntCurveSurface package (for one curve and one surface).
* IntCurveSurface - compute the intersection between a curve and a surface.
* BRepIntCurveSurface - instantiates IntCurveSurface with surfaces from BRep and curves from Adaptor. Intersection between a BRepAdaptor surface and a GeomAdaptor curve, or a Shape and a GeomAdaptor curve. Only the points which are inside the surface are returned.
* IntImp - compute the intersection between a curve and a surface with a close point; ZerCSParFunc for the intersection between a 3d curve and a surface; ZerCOnSSParFunc for the intersection between a curve on surface and another surface
* IntImpParGen - algorithm to intersect implicit curves and bounded parametric curves
* IntPatch - compute the intersection between two patches, the class PatchIntersection implements the intersection algorithms and the results of the algorithms are described by IntPoint, PointOnDomain, Line, ILin, etc.
* IntRes2d - defines the results of the intersection between 2D curves, also includes the definition of a domain on a 2D curve.
* IntSurf - resources for all the packages concerning intersection between surfaces. Uses gp and GeomAbs. Provides: PntOn2S, LineOn2S, Quadric, QuadricTool, PathPoint, SequenceOfPathPoint, PathPointTool, InteriorPoint, Transition, MakeTransition, etc. enumeration Situation is Inside, Outside, Unknown.
* IntTools - classification of intersections. Range, CommonPrt, Root, Compare, CompareRange, EdgeEdge, EdgeFace, FClass2d (classification of a point in a face), LineConstructor (post-processing of results of surfaces intersection), MarkedRangeSet, PntOnFace, PntOn2Faces, QuickSortRange (from SortTools), Length (of an edge), RemoveIdenticalRoots, SortRoots, FindRootStates, GetRadius, etc.
* IntStart - algorithms to find points on boundaries and points inside a surface used as starting points for marching algorithms. Uses TopAbs, GeomAbs, gp, IntSurf and math.
* IntWalk - "walking" (marching) algorithms for the intersection between two surfaces. One of the surfaces is parametric. If the other surface is an implicit surface then the IWalking class will be used. If both surfaces are parametric then the PWalking class will be used.
* Intf - compute interference between polygons, lines and polyhedra with only triangular facets. These objects are polygonal representations of complex curves and triangulated representations of complex surfaces. See also IntPolyh.
* IntPolyh - algorithm to compute starting points for the surface-surface intersection packages. Those starting points are used if the two surfaces are bi-parametric surfaces (bezier, nurbs, algorithm surfaces, ...). This package provides methods to: (1) compute meshes on the two surfaces, a major improvement to the Intf package which gives the same kind of resources. (2) to intersect the two meshes. (3) to give approximated starting-points. Those points are organized in lines, when the points belong to a same section line, or returned as isolated oints when they can neither define a new line nor be linked to an existing line. A starting-point contains 3d information, parametric information and quality criterion (i.e., X,Y,Z, U1,V1, U2,V2, Incidence). Incidence is a real which gives an estimated angle between the two surfaces near the intersection point.
* GeomInt - intersections between two surfaces of Geom. The results are curves from Geom.
* Geom2dInt - intersection between two curves from Geom2dAdaptor. Classes Geom2dCurveTool, CurveTool, IntCurveCurveGen, IntCurve.

classification stuff:

* TopClass - classification algorithms, used to compute if a point is inside, outside or on the boundary of a Shape. Uses gp, TopTrans, TopAbs, TopoDS, IntRes2d, IntCurveSurface, TopExp.
* BRepTopAdaptor - some classification stuff?
* BRepClass - BRep topology classification algorithms. Uses TopClass. Edge, Intersector, FacePassiveClassifier, FaceExplorer, FClassifier, FaceClassifier.
* BRepClass3d - BRep topology classification algorithms, for solids. Intersector3d, SolidExplorer, SolidPassiveClassifier, SClassifier, SolidClassifier, OuterShell.

topology stuff:

* Primitives - algorithms to build topological primitives. Algorithm to build rotational primitives. The wedge algorithm builds boxes and wedges. Uses only gp.
* TopExp - tools for exploring topological data structures. Explorer: a tool to find all subshapes of a given type, such as all faces of a solid. Package methods to map subshapes of a shape.
* TopLoc - handle 3D local coordinate systems (called Locations). A Location is a composition of elementary coordinate systems, each one is called a Datum. The Location keeps track of this composition.
* TopoDS - Provides methods to cast objects of class TopoDS\_Shape to be objects of more specialized types. TopoDS types here: Builder, Compound, Compound, CompSolid, Edge, Face, HShape, Iterator, Shape, Shell, Solid, TCompound, TCompSolid, TEdge, TFace, TShape, TShell, TSolid, TVertex, TWire, Vertex, Wire.
* TopTools - utilities for topological data structures. ShapeMapHasher, OrientedShapeMapHasher, Instantiations of TCollection for Shapes (MapOfShape, IndexedMapOfShape, DataMapOfShapeReal, etc.). Dump will dump the topological of a Shape.
* TopAbs - Topology data structure, topological algorithms. Describes a ShapeEnum for different topological shapes. Orientation enumeration to describe the orientation of a topological shape. State numeration to describe the position of a point relative to a Shape. Methods to manage the enumerations.
* Sweep - create swept 3D primitives, based on TopAbs
* BRepSweep - same thing as the Sweep package, except for the BRep data structure. Translation, Rotation, Prism, Revol. Simple methods to build prism, to build Revol. NumLinearRegularSweep. Also uses TopoDS.
* TopBas - Data structure for topological algorithms. Interference list: an interference is the topological representation of an intersection.
* ShapeCustom - Intended to convert geometrical objects and topological shapes. The modifications of one geometrical object to another (one) geometrical object are provided. The supported modifications are as follows: (1) conversion of BSpline and Bezier surfaces to analytical form; (2) conversion of indirect elementary surfaces (with left-handed coordinate systems) into direct ones; (3) conversion of elementary surfaces to surfaces of revolution; (4) conversion of surface of linear extrusion, revolution, offset surface to bspline; (5) modification of parameterization, degree, number of segments of bspline surfaces, scale the shape.
* ShapeExtend - General tools and data structures common for other packages in SHAPEWORKS and CAS.CADE, including: (1) enumeration status used for coding status flags in methods inside the SHAPEWORKS; (2) enumeration parameterization used for setting global parameterization on the composite surface; (3) class CompositeSurface representing a composite surface made of a grid of surface patches; (4) class WireData representing a wire in the form of ordered list of edges; (5) class MsgRegistrator for attaching messages to the objects; (6) tools for exploring the shapes; (7) tools for creating new shapes.
* TopCnx - This algorithm provides algorithms to compute transitions when many interferences occurs at the same place on a shape. An interference is an intersection on a shape (i.e. a vertex on an edge or an edge on a face) with data about the transition (how the shape is crossing the boundary where the intersection occurs). There are three algorithms to process interferences: (1) EdgeFaceTransition, to process intereferences on an edge crossing other edges on the boundary of a face; (2) EdgeSolidTransition, to process interferences on an edge crossing faces and edges on the boundary of a solid; (3) FaceSolidTransition, to process interferences on a face crossing other faces on the boundary of a solid. This package relies on the TopTrans package for the geometric computations.
* TopTrans - This package provides algorithms to compute complex transitions. A transition is the status of geometry near the boundary of a shape. An example is the intersection of a curve and a surface enclosing a solid, the transition tells if the parts of the curve just before and just after the intersection are inside, outside or on the boundary of the solid. The difficulty with transitions arise when dealing with trimmed geometries like edges and faces. When the geometric intersections are inside the trimmed geometry and the transition is usually computed by the intersection algorithms as the trimming can be safely ignored. If the intersection falls on the trimming boundaries one must consider the neighboring entities. Consider as an example the intersection of a curve and a solid, if the intersection falls on an edge of the solid it does not fall inside the two faces adjacent to the edge, a complex transition occurs. This package provides two classes: (1) CurveTransition, which is used to compute complex transitions with another curve; (2) SurfaceTransition, which is used to compute complex transitions in 3D space. The curves and surfaces are given by a first or second order approximation around the intersection point. For a curve, the tangent vector or the osculating circle. For a surface, the normal vector or the osculating quadric.

topological modification:

* LocOpe - local topological operations on a shape. Splitshape, ProjectedWires, WiresOnShape, Spliter, Generator, GluedShape, Prism, Revol, Pipe, DPrism, LinearForm, RevolutionForm, Gluer, FindEdges, FindEdgesInFace, PntFace, CurveShapeIntersector, BuildShape, SequenceOfCirc, TgtFaces, Closed, IsInside, etc.
* ShapeUpgrade - Tools for splitting and converting shapes by some critera. Topological object splitting or conversion. High level API classes which perform: (1) converting geometry of shapes up to a given continuity; (2) splitting revolutions by U to segments less than given value; (3) converting to beziers; (4) splitting closed faces.
* TopOpeBRep - topological operations on the BRep data structure. PointClassifier, FacesINtersector, ShapeScanner, ShapeIntersector, ShapeIntersector2d, EdgesFiller, FaceEdgeFiller, DSFiller, etc.
* TopOpeBRepBuild - algorithms for topological operation on BRep shapes. These builders work on a data structure that must have been previously filled (by a "filler") according to topological operation rules defined in class DataStructure from TopOpeBRepDS. The DSFiller must be considered as a "linking" tool dealing with geometric data as an input and a DS as an output. These geometric data may be seen as the result of 3D intersection between BRep shapes. AreaBuilder, Pave, ListOfPave, PaveSet, PaveClassifier, EdgeBuiler, FaceBuilder, SolidBuilder, WireToFace, ShellToSolid, FuseFace, CorrectFace2d, Tools2d, IndexedDataMapOfShapeVertexInfo, etc.
* TopOpeBRepDS - used by TopOpeBRepBuild, performing topological operations on the BRep data structure. Interference, ListOfInterference, InterferenceIterator, DataMapOfInterferenceShape, CurvePointInterference, SurfaceCurveInterference, SolidSurfaceInterference, ShapeShapeInterference, EdgeVertexInterference, FaceEdgeInterference, Surface, Curve, Point, GeometryData, SurfaceData, PointData, CurveData, ShapeData, ShapeSurface, SurfaceIterator, CurveIterator, PointIterator, SurfaceExplorer, CurveExplorer, PointExplorer, Dumper, EdgeInterferenceTool, Edge3dInterferenceTool, FaceInterferenceTool, IsGeometry, IsTopology, KindToShape, ShapeToKind, etc.
* TopOpeBRepTool - used by TopOpeBRep to perform topological operations on the BRep data structure. ShapeExplorer, ShapeClassifier, various indexes and maps, makeTransition, PurgeInternaledges, PurgeClosingEdges, FuseEdges, MakeFaces, Regularize, RegularizeWires, RegularizeFace, RegularizeShells, etc.

topology api:

This is according to the [documentation](http://dev.opencascade.org/doc/overview/html/occt_user_guides__modeling_algos.html#occt_modalg_1_2) on "the topology API".

* BRepAlgoAPI
* BRepBuilderAPI
* BRepFilletAPI
* BRepFeat
* BRepOffsetAPI
* BRepPrimAPI

BReps:

* BRep - boundary representation data structure inherited from the abstract topology defined in the TopoDS package. The geometric data are provided by the Geom and Geom2d packages. Face, Edge, CurveRepresentation, Curve3D, GCurve, CurveOnSurface, CurveOnClosedSurface, PolygonOnTriangulation, PolygonOnClosedTriangulation, PolygonOnSurface, PolygonOnClosedSurface, CurveOn2Surfaces, PointOnCurve, PointsOnSurface, PointOnCurveOnSurface, PointOnSurface, etc.
* BRepAdaptor - adaptor compatibility classes to access the geometry of the BRep models. Surface, Curve, Curve2d.
* BRepLib - general BRep utilities, like FindSurface to compute a surface through a set of edges, and compute missing 3d curve on an edge. EdgeError, WireError, FaceError, ShellError, ShapeModification, MakeShape, MakeVertex, MakeEdge, MakeEdge2d, MakePolygon, MakeFace, MakeWire, MakeShell, MakeSolid, FindSurface (find a surface in a set of edges), FuseEdges, BuildCurve3d, BuildCurves3d, UpdateEdgeTolerance, UpdateTolerances, OrientClosedSolid, SortFaces, EncodeRegularity, etc.
* BRepTools - utilities for BRep stuff. WireExplorer, for exploring the topology of a wire in the order of the edges. UVBounds, methods to compute the limits of the boundary of a face, a wire, or an edge in the parametric space of a face. Compare two edges, two vertices. OuterWire, a method to find the outer wire of a face. Dump, a method to dump a BRep object. Quilt, a tool to glue shapes on edges, for example to glue faces to make a shell. Sewing, to assemble contiguous shapes into one shape, identify contiguous boundaries (for control of continuity: C0, C1, ...).
* BRepFeat - creation and manipulation of form features and mechanical features in BRep. Form features can be depressions or protrusions and includes the types Cylinder, Draft Prism, Prism, Revolved feature, Pipe. (more description in the cdl file)
* BRepProj - cylindrical and conical projections, moved out of BRepAlgo because of a cyclic dependency with BRepFill. Provides conical and cylindrical projections of Edge or Wire on a Shape from TopoDS. The result will be an Edge or Wire from TopoDS.
* BRepPrim - like the Primitives package, except for BRep topology. OneAxis, Wedge. Rotational primitives inherited from OneAxis including revolution of a cylinder, cone, sphere, torus. FaceBuilder is a tool to build a face from a Geom surface.
* BRepBuilderAPI - create vertices, edges, faces, solids, sweeps, boolean operations, sweeping operations, global properties computation. For tolerances a default precision is used which can be changed by the Precision function. MakeEdge, MakeEdge2d, MakeFace, MakePolygon, MakeShape, MakeShell, MakeSolid, MakeVertex, MakeWire, ModifyShape, NurbsConvert, Sewing, Transform, VertexInspector, etc. See also BRepFilletAPI for fillets and chamfers. See also BRepPrimAPI for MakeBox, MakeCylinder, MakeSphere, MakeTorus, MakePrism, etc.
* BRepPrimAPI - some extra stuff that BRepBuilderAPI was missing, like MakeBox, MakeWedge, MakeCylinder, MakeCone, MakeSphere, MakeTorus, MakeRevolution, MakePrism, MakeRevol. Uses BRepPrim.
* BRepOffsetAPI - dunno, does some BRepBuilderAPI stuff
* BRepCheck - validity checking of BRep, checks for things like self intersection, also has a Status enumeration
* BRepExtrema - compute extrema between shapes from BRep. DistanceShapeShape.
* BRepGProp - compute a shape's global properties for lines, surfaces or volumes. The global properties computed for a system are its mass, center of mass, matrix of inertia, moment about an axis, radius of gyration about an axis, and its principal properties of inertia such as principal axis, principal moments, principal radius of gyration.
* BRepLProp - compute the degree of continuity of a curve built by concatenation of two edges at their junction point. Uses gp, BrepAdaptor, GeomAbs, LProp.
* BRepOffset - dunno, some intersection stuff, BRepOffset\_Skin describes the offset along the surface of a solid, used to obtain a manifold topological space; BRepOffset\_Pipe describes the offset of a curve, used to obtain a pre-surce; BRepOffset\_RectoVerso describes the offset of a given surface shell along both sides of the surface.

boolean operations on BReps:

* BRepAlgo - deprecated boolean operations, see BrepAlgoAPI instead.
* BRepAlgoAPI - algorithms for boolean operations for shape arguments that are defined in the BRep data structure. The new algorithm is based on an approach to operations with interfered shapes. It can handle two solids with shared entities (in terms of TopoDS\_Shape::IsSame()), two faces that have shared edges and so on. Also, there's a general treatment of same-domain faces. Two faces that share the same domain are processed according to the common rule even if the underlying surfaces are of different types. This allows the proper execution of boolean operations for the same domain faces. Also it works on solids and shells that have the same domain faces. It is quite frequent that two faces share the same domain. Degenerated edges are handled, although there are still some difficulties processing faces in areas close to degenerated edges. For arguments with the same shape type (ex: SOLID and SOLID), the type of the resulting shape will be a COMPOUND, containing shapes of this type. For arguments with different shape types (ex: SHELL and SOLID), the type of the resulting shape will be a COMPOUND, containing shapes of the type that is the same as that of the lowest type of the argument, like if SHELL and SOLID then the result is a COMPOUND of SHELLs. For arguments with different shape types some boolean operations cannot be achieved with the default implementation because of a non-manifold type of the result, like the FUSE operation for SHELL and SOLID can't be done, but the CUT operation can be done, where SHELL is the object and SOLID is the tool.

probably related to boolean operations, but not sure what these are:

* BOPAlgo - no description. Classes: BuilderShape, PaveFiller, Builder, BOP, BuilderFace, WireEdgeSet, WireSplitter, ShellSplitter, BuilderArea, BuilderSolid, enumeration Operation is COMMON, FUSE, CUT, CUT21, SECTION, UNKNOWN; enumeration CheckStatus is CheckUnknown, BadType, SelfIntersect, TooSmallEdge, NonRecoverableFace, IncompatibilityOfVertex, IncompatibilityOfEdge, IncompatibilityOfFace,, OperationAborted, NotValid, etc.
* BOPDS - data structures for general fuse and boolean operation algorithms, like: Iterator, Pave, PaveBlock, SubIterator, Point, Curve, FaceInfo, Interf, InterfVV, INterfVE, INterfVF, InterfEE, InterfEF, InterFF, InterfVZ, InterfEZ, InterfFZ, InterfZZ, VectorOfInterfVV, VectorOfInterfVE, VectorOfInterfVF, etc.
* BOPCol - collection classes used by the partition and boolean operation algorithms, lots of ListOfList and sequences and maps and indexes and MapOfShape etc..
* BOPTools - no description, various MapShapes, probably collections-related?
* BOPInt - no description, provides class Range and ShrunkRange. IsOnPave1. IsInRange - checks if two ranges interfere with each other. ShrunkRange computes a working (shrunk) range of \[t1, t2\] for the 3D curve of the edge.

chamfers and fillets:

* ChFi2d - algorithms to build fillets or chamfers on planar wire
* ChFi3d - creation of spatial fillets on a solid
* ChFiDS - fillet and chamfers data structure
* FilletSurf - API giving only geometric information about fillets for Toyota Project UV4. TwoExtremityOnEdge, OneExtremityOnEdge, NoExtremityOnEdge, etc.
* ChFiKPart - Fonctions de remplissage pour une SurfData, dans les cas particulers de conges/chanfreins suivants: cylindre/plan entre 2 surfaces planes; tore/sphere/cone entre un plan et un cylindre othogonal; tore/sphere/cone entre un plan et un cone othogonal; tore/sphere/cone entre un plan et un tore othogonal; tore/cone entre un plan et une sphere.
* BRepFilletAPI - MakeFillet, MakeChamfer, MakeFillet2d, see also BRepBuilderAPI.

shape healing:

* ShapeAnalysis - Analyze geometrical objects and topological shapes. Analysis domain includes both exploring geometrical and topological properties of shapes and checking their conformance to OpenCASCADE requirements. The directions of analysis provided by tools of this package are: computing quantities of subshapes; computing parameters of points on curve and surface; computing surface singularities; checking edge and wire consistency; checking edges order in the wire; checking face bounds orientation; checking small faces; analyzing shape tolerances; analyzing free bounds of the shape.
* ShapeBuild - basic building tools for other packages in ShapeHealing, internal stuff
* ShapeFix - Shape healing, algorithms for fixing problematic (violating OpenCASCADE requirements) shapes. Tools from package ShapeAnalysis are used for detecting the problems. The detecting and fixing is done taking in account various criteria implemented in BRepCheck package. Each class of package ShapeFix deals with one certain type of shapes or with some family of problems.
* ShapeProcess - customizable sequence of shape healing operators. The customization is implemented via user-editable resource file which defines sequence of operators to be executed and their parameters.
* ShapeProcessAPI - (description is probably wrong, see name) tools for converting shapes for data exchange between various systems (CATIA, EUCLID3, etc.)
* SHMessage - shape healing messages
* MoniTool - monitor data exchange and shape healing, timers for measuring performance

hatching:

* Hatch - algorithm to compute cross-hatchings on a 2D face. The Hatcher algorithms stores a set of lines in the 2D plane. The user stores lines in the Hatcher and afterward trim them with other lines. At any moment when trimming the user can ask for any line if it is intersected and how many intervals are defined on the line by the trim.
* HatchGen - intersection type between the hatching and the element
* Geom2dHatch - uses HatchGen, Geom2DAdaptor stuff, probably hatching stuff

hidden lines removal algorithms:

* HLRAlgo - hidden lines removal algorithms
* Intrv - intervals; defines enumeration Position (Before, JustBefore, OverlappingAtStart, JustEnclosingAtEnd, Enclosing, JustOverlappingAtStart, Similar, JustEnclosingAtStart, Inside, JustOverlappingAtEnd, OverlappingAtEnd, JustAfter, After). Also defines an Interval, Intervals, SequenceOfInterval. This is only used by the hidden lines removal algorithm package (HLRAlgo).
* HLRAppli - applications of the hidden lines removal algorithm
* HLRBRep - Hidden Lines Removal algorithms on the BRep DataStructure. The class PolyAlgo is used to remove hidden lines on Shapes with Triangulations.
* HLRTopoBRep - This package provides some topological reconstruction services needed by the hidden line removal algorithms using OutLine and IsoLine facilities, applied to an object represented by a BRep data structure.

plates and constraints (not sure):

* Plate - something about constraints? see online documentation
* NLPlate - more constraint stuff? not much
* GeomPlate - plate constraint stuff again?

meshing:

* Poly - handle 3D triangular polyhedrons, 3D polygons, 2D polygons. Also, tools to dump, save and restore those objects.
* BRepMesh - mesh algorithms and triangulation algorithm. Has a mesh factory. Algorithm to mesh a shape with respect to the frontier the deflection and by option the shared components. Algorithm to mesh a face.
* XBRepMesh - one single function called "Discret" that runs BRepMesh\_IncrementalMesh on a TopoDS\_Shape and an angle and a deflection.

STL stuff:

* RWStl
* StlAPI
* StlMesh
* StlTransfer

STEP stuff:

* TopoDSToStep - This package implements the mapping between CAS.CAD Shape representation and AP214 Shape Representation. The target schema is pms\_c4 (a subset of AP214). Some of the entry points are: MakeManifoldSolidBrep, MakeBrepWithVoids, MakeFacetedBrep, MakeFacetedBrepAndBrepWithVoids, MakeShellBasedSurfaceModel. Each of these classes calls the Builder.
* StepAP203 - Contains implementation of STEP entities specific for AP203
* StepAP209 - Basic tool for working with AP209 model
* StepAP214 - Complete AP214 CC1 , Revision 4. Upgrading from Revision 2 to Revision 4 : 26 Mar 1997. Splitting in sub-schemas : 5 Nov 1997.
* StepBasic - Collects definitions of STEP entities from Part 41 of ISO 10303.
* STEPCAFControl - CAF translation control between opencascade and STEP. Attributes, external references, etc.
* STEPConstruct - Defines tools for creation and investigation STEP constructs used for representing various kinds of data, such as product and assembly structure, unit contexts, associated information. The creation of these structures is made according to currently active schema (AP203 or AP214 CD2 or DIS). This is taken from parameter "write.step.schema".
* STEPControl - control of translation between opencascade and STEP types
* StepData - Gives basic data definition for Step Interface. Any class of a data model described in EXPRESS Language is candidate to be managed by a Step Interface.
* StepDimTol - definition of STEP GD&T entities TR12J
* STEPEdit - Provides tools to exploit and edit a set of STEP data, editors, selections
* StepElement
* StepFEA
* StepFile
* StepGeom - AP214 CC1 , Revision 4  for Geom (Part42, geometric) Upgrading from Revision 2 to Revision 4 : 26 Mar 1997
* StepRepr - Sub-Schema of Step for Representations. Collects definitions of STEP entities used for describing representation structures (from Parts 41, 43, 44 of ISO 10303)
* StepSelect - defines the library of the tools used for every kind of STEP Files, i.e. whatever the considered Protocol.
* STEPSelections
* StepShape - Collects definitions of STEP topological entities from Part 42 of ISO 10303 (topology\_schema)
* StepToGeom - Creation des entites geometriques de Geom a partir du schema StepGeom (Part42, geometric)
* StepToTopoDS - Implements the mapping between AP214 Shape representation and  CAS.CAD Shape Representation. The source schema is Part42 (which is included in AP214).
* StepVisual - Collects definitions of STEP entities for visual presentations from Part 46 of ISO 10303
* APIHeaderSection - access the header of a STEP model
* GeomToStep - Creation des entites geometriques du schema PmsAp2Demo3d a partir des entites de Geom ou de gp. Update: mise a jour pour traiter le schema StepGeom, pour demo de 94.

* XSAlgo - Provides initerface to the algorithms from Shape Healing and others for XSTEP processors.
* XSMessage - error message translation for IGES and STEP
* XSTEPResource - resource files for data exchange

* RWHeaderSection
* RWStepAP203
* RWStepAP214
* RWStepBasic
* RWStepDimTol
* RWStepElement
* RWStepFEA
* RWStepGeom
* RWStepRepr
* RWStepShape
* RWStepVisual

IGES stuff:

* BRepToIGES - Provides tools in order to transfer CAS.CADE entities to IGES.
* IGESToBRep
* BRepToIGESBRep - Provides tools in order to transfer CAS.CADE entities to IGESBRep.
* GeomToIGES - Creation des entites geometriques de IGES a partir des entites de Geom.
* Geom2dToIGES - Creation des entites geometriques de IGES a partir des entites de Geom2d.
* IGESAppli
* IGESBasic
* IGESCAFControl
* IGESControl
* IGESConvGeom
* IGESData
* IGESDefs
* IGESDimen
* IGESDraw
* IGESFile
* IGESGeom - B-Rep and CSG Solid entities
* IGESGraph
* IGESSelect
* IGESSolid

XML stuff:

* XmlDrivers
* XmlLDrivers
* XmlMDataStd
* XmlMDataXtd
* XmlMDF
* XmlMDocStd
* XmlMFunction
* XmlMNaming
* XmlMPrsStd
* XmlMXCAFDoc
* XmlObjMgt
* XmlOcafResource
* XmlTObjDrivers
* XmlXCAFDrivers

VRML stuff:

* Vrml
* VrmlAPI
* VrmlConverter
* VrmlData

DECAF or XCAF file format stuff(?):

* XCAFApp - defines application for DECAF document and provides application-specific tools
* XCAFDoc - definition of DECAF document and how to work with it
* XCAFDrivers - various drivers
* XCAFPrs - Presentation (visualiation, selection etc.) tools for DECAF documents
* XCAFSchema - dunno

transient data structures:

* TColGeom
* TColGeom2d
* TColgp
* TCollection
* TColQuantity
* TColStd
* TDF - tagging?
* TDocStd - document management-related
* TDataStd
* TDataXtd
* TFunction
* TNaming
* TShort - arrays of shorts, TCollection transient related
* HeaderSection
* CDM - transient document stuff

persistence and database related packages:

* TransferBRep - read files and convert them to shapes from CasCade. It can be used in conjunction with purely CasCade software.
* ShapeSchema - inheritance and persistence basic tools
* Storage - read and write persistent objects
* Dynamic - abstract persistent classes
* MDataStd
* MDataXtd
* MDF - translate a transient DF into a persistent one and vice versa
* MDocStd - Drivers for TDocStd\_Document, uses a bunch of persistence stuff
* MFunction
* MNaming
* MgtBRep
* MgtGeom
* MgtGeom2d
* MgtPoly
* MgtTopLoc
* MgtTopoDS
* MPrsStd
* TPrsStd
* PPrsStd - AIS presentation related
* MXCAFDoc
* ObjMgt
* PDF
* PDocStd
* PFunction
* PBRep
* PCollection
* PColgp
* PColStd
* PColPGeom
* PColPGeom2d
* PDataStd
* PDataXtd
* PGeom
* PGeom2d
* PNaming
* PPoly - 3D triangular polyhedrons, 3D polygons, 2D polygons
* PStandard
* PTopLoc
* PTopoDS
* PXCAFDoc
* PMMgt (also management)

persistence related toolkit packages:

* PTColStd
* PTKernel

binary drivers for document management stuff:

* BinDrivers - document storage, drivers
* BinLDrivers - document storage related, drivers
* BinMDataStd - Storage and Retrieval drivers for modelling attributes. Storage/Retrieval drivers for TDataStd attributes.
* BinMDataXtd - Storage and Retrieval drivers for modelling attributes.
* BinMDF - driver, driver table, persistence translator
* BinMDocStd - Storage and Retrieval drivers for TDocStd modelling attributes.
* BinMFunction - Storage and Retrieval drivers for TFunction modelling attributes.
* BinMNaming - Storage/Retrieval drivers for TNaming attributes
* BinMPrsStd - Storage-Retrieval drivers for graphic attributes from TPrsStd
* BinMXCAFDoc - drivers
* BinObjMgt - This package defines services to manage the storage grain of data produced by applications. Storage Relocation Table. Retrieval Relocation Table.
* BinTObjDrivers - more drivers
* BinXCAFDrivers - drivers, document stuff

toolkits:

* TKAdvTools
* TKBin
* TKBinL
* TKBinTObj
* TKBinXCAF
* TKBO
* TKBool
* TKBRep
* TKCAF
* TKCDF
* TKDCAF
* TKDraw
* TKernel
* TKFeat
* TKFillet
* TKG2d
* TKG3d
* TKGeomAlgo
* TKGeomBase
* TKHLR
* TKIGES
* TKLCAF
* TKMath
* TKMesh
* TKMeshVS
* TKNIS
* TKOffset
* TKOpenGl
* TKPCAF
* TKPLCAF
* TKPrim
* TKPShape
* TKQADraw
* TKService
* TKShapeSchema
* TKShHealing
* TKStdLSchema
* TKStdSchema
* TKSTEP
* TKSTEP209
* TKSTEPAttr
* TKSTEPBase
* TKSTL
* TKTObj
* TKTObjDRAW
* TKTopAlgo
* TKV3d
* TKVoxel
* TKVRML
* TKXCAF
* TKXCAFSchema
* TKXDEDRAW
* TKXDEIGES
* TKXDESTEP
* TKXMesh
* TKXml
* TKXmlL
* TKXmlTObj
* TKXmlXCAF
* TKXSBase
* TKXSDRAW
* TKTopTest
* TKViewerTest

DRAWEXE test packages:

* DRAWEXE

* SWDRAW
* TObjDRAW
* XDEDRAW
* XSDRAW
* XSDRAWIGES
* XSDRAWSTEP
* XSDRAWSTLVRML

various helpers for testing other packages:

* BOPTest
* BRepTest
* GeometryTest
* GeomliteTest
* HLRTest
* MeshTest
* TestTopOpe
* TestTopOpeDraw
* TestTopOpeTools
* ViewerTest

QA related:

* QABugs
* QADNaming
* QADraw
* QANCollection
* QANewBRepNaming
* QANewDBRepNaming
* QANewModTopOpe

basic types:

* MMgt - The package MMgt provides single class TShared which is second in hierarchy of inheritance from Standard\_Transient, kept for historic reasons.
* Standard - provides the minimum services necessary for other toolkits to handle persistent and transient objects. It is the Standard run-time encapsulation of the CAS.CADE database, that is, it defines a single programming interface for creating and accessing persistent objects manipulated by handles.
* StdFail - NotDone, Undefined, UndefinedDerivative, UndefinedValue, InfiniteSolutions
* StdDrivers - retrieves drivers
* StdLDrivers - returns a list of storage or retrieval attribute drivers, used for plugins
* StdLSchema - just references other packages?
* StdPrs - provides standard display tools for specific geometries and topologies whereas Prs3d provides those for generic objects. Among these classes are definitions of the display of the specific geometry or topology in various display modes such as wireframe, shading or hidden line removal mode.
* StdResource - no clue, something about TObj, XCAF, Standard, StandardLite, etc.
* StdSchema - empty? no clue
* DDF - Provides facilities to manipulate data framework in a Draw-Commands environment.
* DDataStd - commands for Standard Attributes
* DDocStd - provides Draw services to test CAF standard documents (see TDocStd package). Provides: Modification registration and Update management; External references mechanism; UNDO/REDO; Document Creation, Save and Restore.
* Dico - dictionary iterator stuff
* NCollection - collection types
* BinTools - Tool to keep shapes in binary format, works with some streams

* Prs3d - display related
* PrsMgr - manages display, see AIS
* Transfer - Defines general transfer engine, which provides tools and workframe for all kinds of file (non-direct) interfaces. Works on the basis of data provided by package Interface (especially InterfaceModel). 
* Interface - data interfacing, file transfering, see package Transfer

* Message - basic tools for progress indication
* SortTools

selection of objects in 3d:

* Select3D
* SelectBasics
* SelectMgr
* StdSelect - selection modes for topological shapes
* AIS - Application Interactive Services to provide links between application GUI viewer and the packages which are used to manage selection and presentation
* DPrsStd - commands for presentation based on AIS

graph related:

* GraphDS - describes transient graph data structure stuff
* GraphTools
* IFGraph - Provides tools to operate on an InterfaceModel and its Entities as on a Graph. These Tools are based on classes Graph and GraphContent from Interface. Uses Interface, GraphTools, TColStd, Standard.
* IFSelect
* XSControl - complements to IFSelect & Co for control of a session

units:

* Units - Create and question a dictionary of units, and also manipulate measurements which are real values with units.
* UnitsAPI - convert a value from any unit into another unit. Conversion is executed among three unit systems: (1) SI system, (2) user's local system, (3) the user's current system. The MDTV system corresponds to the SI international standard but the length unit and all its derivatives use the millimeter instead of the meters.
* UnitsMethods - degree2radians, radians2degree, other functions
* Quantity - mathematical and physical quantities; MagneticFluxDensity, ElectricCapacitance, Enthalpy, SpecificHeatCapacity, Volume, etc.
* Precision - it is not advisable to use floating number equality
* Materials - apply physical properties to objects

visualization:

* Aspect - graphic elements for visualizers
* Graphic3d - create 3d graphic objects in a visualizer
* V3d - 3D visualizer stuff, complementary to Visual3d
* Visual3d - implementation of commands for the 3d visualizer
* Voxel - Data structure and visualization engine for voxel modeling.
* OpenGl
* Shaders
* Textures - rgb files
* Draw - Drawable3D stuff?
* DrawDim - drawable dimensions, like PlanarDimension
* DrawFairCurve - Batten and MVC to display
* DrawResources - some tcl stuff, other things?
* DrawTrSurf - Supports the display of parametric curves and surfaces. The Drawable deferred classes is inherited from the Drawable3D class from the package Draw, it adds methods to draw 3D curves and curves on 3D surfaces. The classes Curve, Curve2D and Surface are drawable and can be used to draw a single curve from packages Geom or Geom2d or a surface from Geom. Triangulation and Polygon from the package Poly are also supported.
* DBRep - Used to display BRep objects  using the DrawTrSurf package. The DrawableShape is a Display object build from a Shape. Provides methods to manage a directory of named shapes. Provides a set of Draw commands for Shapes.
* MeshVS - presentation stuff; displaying of mesh; colors, vectors, texts; selection of mesh entities (except hidden ones)
* InterfaceGraphic - dunno, has some Windows NT stuff, has some X11 stuff, XWD stuff, Visual3d things, etc..

operating system related:

* OSD - operating system dependent tools
* Cocoa - Objective C stuff
* Xw - X11 stuff? windowing
* WNT - common Windows NT graphics interface

other:

* Font - system font stuff, also a brep font
* UTL - file handling?
* FSD - file stream stuff
* Image - image manipulation for pixmaps

no idea:

* PShort
* TObj
* DsgPrs - Describes Standard Presentations for DsgIHM objects
* DBC
* DNaming
* NIS
* OS - some tcl code?
* Plugin - load a plugin
* ShapeAlgo - something about an AlgoContainer?
* Resource - A RESOURCE is a parameter saved on a file and used to initialize a variable.
* IncludeLibrary
* CDF - database related maybe?
* PCDM - probably related to document management?
* PCDMShape - something about a document
* LDOM
* LibCtl
* FWOSDriver
* FWOSPlugin
* AppStd - just has one thing ("Application")
* AppStdL - same as AppStd?
* FEmTool - finite element methods; LinearTension, LinearFlexion, LinearJerk, SparseMatrix, Curve, ProfileMatrix, some others.
