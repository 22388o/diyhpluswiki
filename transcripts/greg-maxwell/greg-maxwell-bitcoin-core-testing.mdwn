Name: Greg Maxwell

Topic: Bitcoin Core testing

Location: Unknown

Date: Unknown

# Bitcoin Core testing

Directing more effort into testing has been a long term challenge for us, in part because the art and science of testing is no less difficult than any other aspect of the system’s engineering. Testing involves particular skills and aptitudes that not everyone has.

What I’ve found is that when you ask people who aren’t skilled at testing to write more tests what they generally write are rigid, narrow scope, known response tests. So what they do is imagine the typical input to a function (or subsystem), feed that into it, and then make the test check for exactly the result the existing function produces. This is sort of test is of very low value: It doesn’t test extremal conditions, especially not the ones the developer(s) hadn’t thought of (which are where the bugs are most likely to be), it doesn’t check logical properties so it doesn’t give us any reason to think that the answer the function is currently getting is *right*, and it will trigger a failure if the behavior changes even if the change is benign, but only for the tested input(s). They also usually only test the smallest component (e.g. a unit test instead of a system test) and so they can’t catch issues arising from interactions. These sorts of tests can be worse than no test in several ways: they falsely make the component look tested when it isn’t, and they create tests that spew false positives as soon as you change something which both discourages improvements and encourages people to blindly update tests and miss true issues. A test that alerts on any change at all can be appropriate for normative consensus code which must not change behavior at all, but good tests for that need to test boundary conditions and random inputs too. That kind of test isn’t very appropriate for things that are okay to change.

In this case, our existing practices (even those of two years ago) would have been at least minimally adequate to have prevented the bug. But they weren’t applied evenly enough. My cursory analysis fo the issue suggests that there was a three component failure: The people who reviewed the change had been pre-primed by looking at the original introduction of the duplicate tests which had a strong proof that the test was redundant. Unfortunately, later changes had made it non-redundant apparently without realizing it. People who wouldn’t have been snowed by it (e.g. Suhas never saw the change at all, and since he wasn’t around for PR443 he probably wouldn’t have easily believed the test was redundant) just happened to miss that the change happened, and review of the change got distracted by minutia which might have diminished its effectiveness. GitHub, unfortunately doesn’t provide good tools to help track review coverage. So this is an area where we could implement some improved process that made sure that the good things we do are done more uniformly. Doing so probably won’t make anything slower. Similarly, a more systematic effort to assure that all functionality has good tests would go a long way: New things in Bitcoin tend to be tested pretty well, but day zero functionality that never had tests to begin with isn’t always.

It takes time to foster a culture where really good testing happens, especially because really good testing is not the norm in the wider world. Many OSS and commercial projects hardly have any tests at all, and many that do hardly have good ones. (Of course, many also have good tests too… it’s just far from universal.) We’ve come a long way in Bitcoin— which originally had no tests at all, and for a long time only had unit tests that were nearly useless (almost entirely examples of that kind of bad testing). Realistically it’ll continue to be slow going especially since “redesign everything to make it easier to test well” isn’t a reasonable option, but it will continue to improve. This issue will provide a nice opportunity to nudge people’s focus a bit more in that direction.

I think we can see the negative effect of “go slower” in libsecp256k1. We’ve done a lot of very innovative things with regard to testing in that sub-project, including designing the software from day one to be amenable to much stronger testing and had some very good results from doing so. But the testing doesn’t replace review, and as a result the pace in the project has become very slow— with nice improvements sitting in PRs for years. Slow pace results in slow pace, and so less new review and testing happen too… and also fewer new developments that would also improve security get completed.
