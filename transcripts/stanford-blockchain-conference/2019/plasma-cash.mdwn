Plasma Cash: Towards more efficient Plasma constructions

Georgios Konstantopolous (gakonst)

Shi: Okay, we're going to start the next session. Please return to your seats. I have an important announcement before the session starts. Because of the fire code, we can't allow people standing room. Please go to the overflow rooms at the end of the hallway. We don't want the fire marshall to come and shutdown the conference. Also, the acoustics of the room make it so that we can hear the details of your conversations in the back. Our first talk in this session is about Plasma Cash.

# Introduction

Hi everyone, thank you for coming. I'm going to talk about plasma and plasma cash which was introduced in 2017 by Vitalik Buterin and Joseph Poon. Since then, the technique has evolved a lot. I'm here to talk about what it can do and can't do. In ethereum, it's been a big buzzword so let's talk about limits.

# Table of contents

I'll describe how transactions work, how you can get transactions into and out of plasma, what are the security assumptions they have, and what we can do in the future to make it even better.

# Related work

Related work includes sidechains with two-way pegs like merged mining svp proof or NiPoPoWs, or federated pegs using multisig. Also, there's drivechains which have different properties, and then shadowchains and treechains and client-side validation and NOCUST. I don't understand treechains. NOCUST is similar to plasma.

# Plasma

Plasma is a framework for creating non-custodial sidechains. In the normal model, in a sidechain you get your funds in, you do transactions, then you do a special transaction to do a peg-out transaction. There's some spending conditions and an escrow contract. But if the sidechain doesn't allow you to exit and unlock the funds on the parent chain, or if the multisig participants are censoring you, then you can't really get your funds and they are stuck. So what do you do?

In plasma, we take each transaction root from each block and commit it to the original chain. If we want to do scalability, rather than having a decentralized chain, we have some untrusted database manager which in plasma lingo is the "operator" and it's responsible for maintaining the state of the chain and it makes block commitments. The operator doesn't need to be trusted. You cannot assume the state transitions will be valid.

So you need to introduce a way that in the case where the state validator makes an invalid state transition then users need to be able to make a dispute.

# Exit game: Delayed withdrawals

At some point, you say you want to start an exit. You go to an escrow contract, you say please unlock my funds, you have a timelock, and then after that point the transaction is finalized and you got your funds out. But if in the case that there's a dispute, some other party will do a challenge transaction which will cancel the exit.

# Non-fungible Plasma, aka Plasma Cash

UTXO ID is the leaf index in a sparse merkle tree. The deposit means you receive a coin with a seiral number, just like anonymous cash. For each 1 input you get 1 UTXO. To make a transaction, you reference a parent transaction. To exit, you reveal the transaction and the parent transaction.

# What's a sparse merkle tree?

Let me show you a nice graph. It's an ordered merkle tree where each index of an element is its ID. This allows you to do an inclusion proof. Since it's a sorted ordered merkle tree, you can also do exclusion proofs, where you attest to the inclusion of zero.

# Transfers, exits and challenges

Say I have some funds on the main chain. I deposit them into a smart contract, which then emits an event, which then grants me the funds on the Plasma chain. If the Plasma chain doesn't grant you any funds, then you can withdraw them and simply get them back directly.

Okay, the user now has a coin and she wants to transfer it to another user. Alice transfers to Bob. Bob verifies the coin by checking its history. The transaction history grows with the number of hops, and it all needs to be verified.

The receiver must verify the UTXO history since the coin's deposit, even when the block didn't have a related transaction. You need to send merkle exclusion proofs or merkle nonmembership proofs. So you would have to get this from the last user, or from the operator, or from some data availability provider such as the operator.

You exit by referencing the transaction and where you got it from.

# Exits

We can model each coin as a state machine. When you deposit, it's in the deposited state. E is for exit. When you start an exit, the coin goes to the exiting stage. Then you can wait 7 days, finalize the exit, and then you can go to the next state, and then you can withdraw your coin. By the time you withdraw the coin, it's out of the system.

# Non-interactive challenge

In the other case, say it's an exit and it's a bad exit state, and someone does a non-interactive challenge and I'm back to square one. This enforces that you can't have an invalid state for the coin.

# Interactive challenge

There are also interactive challenges. I can respond within some time period to the interactive challenge. An exit is only valid if it has zero outstanding pending challenges. You could respond to a challenge and then proceed as normal.



