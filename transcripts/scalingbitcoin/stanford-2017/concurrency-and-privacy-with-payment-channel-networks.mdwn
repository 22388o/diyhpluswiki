Concurrency and Privacy with Payment-Channel Networks

Pedro Moreno-Sanchez

# Introduction

I am going to talk about concurrency and privacy. This was joint work with my collaborators.

Bitcoin has scalability issues. That's the main reason why we are here today. Currently the bitcoin network allows for less than 10 transactions/second. Today we have more than 135 gigabytes of memory requirement. And there are some high fees and micropayments are not really possible. One of the proposals to fix this is payment channels.

# Payment channels

For those wo don't know how payment channels work, it allows payments between two users, without putting every payment in the blockchain. In the figure, Alice creates a payment channel with Bob. They will create a deposit with Bob because it's not a network. Alice and Bob might not trust each other. They use a contract that allows the originals to receive their coins back after a certain amount of time. This is called the opening of the channel. Once it's open, they can sign transactions to each other. Once they finish, they can close the channel and send the transactions that go to the network. They get the coins in the channel from the last state they agreed upon. This requires one transaction to open and one to close.

Instead of having a payment channel between every two users, you can use a network of channels. You can use some of the other nodes in the network as an intermediary such that payments are forwarded. In this example, Bob (the intermediary) has to be trusted. We need something that allows us to create multi-hop payment without trusted intermedaries. As for this example, to save time, I will just call it a multi-hop payment.

# Hash time-lock contracts (HTLCs)

In order to have this payment network, we use hash time-lock contracts. You allow conditional payments between users even if they might not trust each other. So Alice is going to pay Bob 1 bitcoin under the condition that Bob shows a value H(x) such that it satisfies the condition. So he has to show this value x and send it to the bitcoin network, and thus show that the one coin that was conditionally paid by Alice.

HTLCs have been proposed for the lightning network to build a multi-hop payment network. Bob will forward the payment with the same condition 'y'. He knows that as soon as 'x' is revealed for the conditional payment with Cat, he can use it to pull coins from Alice. And once this multi-hop payment is settled, Cat can just open this value x, pull the money from Bob, and now Bob takes this x and gets the coins from Alice. These hashed time-lock contracts ensure that it works.

Our contribution is that we are looking at payment channel networks and analyze the privacy and security aspects. We study the issue of concurrency in payment channels.

# Security properties

We considered two security properites. One is called balance security. The main idea is that a payment channel network must ensure that every honest node in the path from a sneder to receiver must not lose coins. If delta here is the balance of the channels that the users have, it must not be the case that the balance changes after the payment because he was an intermediary. The other property is serializability. They must be sequential payments. These two consecutive payments should have the same serialization.

# Privacy properties

From the privacy point of view, we considered two privacy properties. The first one is that off-path value privacy. If someone was not participating in the path, then it means that... if the attacker was in the path, then they know how much was routed in the payment. Anothe rproperty we are after is that on-path relationship anonymity. If the attacker is in the path, then they should not be able to figure out which actual sender sent the payment. So now we have a set of senders, a set of receivers, all of them are spending, you should not be able to figur eout which ones are paying to which.


# Privacy in PCNs

All of the payments happen off-chain. What are the privacy issues then? The problem is that if you have these conditional payments, you can use the same conditions on each of the hops. By looking at the condition, you can figure out which channels are being used. In light of this problem, we are trying to propose a solution to solve this problem.  Our solution is Fulgor: based on multi-hop HTLC method. We want to have standard hash time-lock contract, and take all of the other cryptographic operations and they must be off-chain. We are fully compatible with the current Bitcoin script.

The solution we propose is Fulgor. It's multi-hop HTLCs.

# Multi-hop HTLCs

We use a building block called non-interactive zero knowledge (ZKBoo [GMO16]). There are two things-- x0 and x1 and y0 and y1.






