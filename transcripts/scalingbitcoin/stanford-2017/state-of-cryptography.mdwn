State of cryptography for blockchains beyond ECDSA and sha256

Signatures and zero-knowledge proofs

Benedikt Bunz, Stanford University

Am going to talk about cryptography relevant to blockchains. I'll talk about signatures and zero-knowledge proofs. It has a lot of applications to bitcoin. It turns out that bitcoin is pretty simple in terms of cryptography. It just uses a hash function (sha256) and,s eparately, ECDSA for signatures. I will be mentioning some other cryptography that bitcoin could use.

Let's start with signatures. What do signatures do? If Bob wants to say, on every e-cash system, Bob says he is going to send 1 coin to Alice, but the problem is how does Alice know whether Bob said this or was this just from someone else or how does a third person verifyin miner check that actually Bob issued this transaction? Well, what we do is use somethin called authorization. Bob signs the message with a digital signature. This signature has properties like it's unforegeable. So let's look at a more formal definition.

A signature scheme has three algorithms: key generation, signing something that takes the message and the private key, and then the verification algorithm that uses the public key (without access to the private key) and the signature and the message and then outputs true or false. You obviously want the one important property which is that if the signature is created ocrrectly, then the verifier will say this is the correct signature. The security is that even if I see many different signatures, then nobody should be able to forge a new signature on a new message. I might be able to reuse a signature on an old message, but I cannot sign a different transaction, unless I have the secret key.

In general, this is what it looks like. You first send the public key, and then you send a signature and message and then Alice verifies it. You can use one public key, or in some cases you can use public key multiple times but perhaps you shouldn't. Bitcoin uses ECDSA and it's a complex protocol and it was designed like that because of a patent conflict with Schnorr signatures, but that patent has expired. ECDSA kind of took over the internet and the market because nobody wanted to use a patent-encumbered signature schemes.

One of the many problems with ECDSA is that it's malleable. if you remember the security definition, it said you cannot create a signature on a new message. But you can create a new signature on an old message. In ECDSA, you can take one signature on one message and create a different signature on that same message. Well why would this matter? It's like using a different color for your signature. But in bitcoin this causes transaction malleability problems. So suddenly you have a new txid, it's different, but still valid. It doesn't send money to different people, but it causes lots of other problems because you can't predict the final txid is going to be, and transactions spend coins based on txid. MtGox got fooled on this because they were issuing withdrawal transactions and then somehow they would check an hour later to see whether it was accepted, they would check with "txid" and if it wasn't they would send out the money again. Someone figured this out and just issued withdrawal transactions by changing the signatures, and mtgox would send the money again and again and again. This is one of the ways that mtgox lost a lot of money. So security matters.

Let's talk about some different signature schemes. I am going to go through discrete log and pairings. You have probably seen the discrete log problem ,and it basically just says that g and g^x it's hard to produce x. It's basically impossible unless you'[re a quantum computer. So the other preliminary is this so-called pairing. A pairing is this construct which takes two things from two elements from this group and it takes g^a and g^b and then you can pair it and map it to an element in the so-called target group. This pairing has this property that the pairing of g^a and g^b is equivalent to the pairing of g g and a times b. This is bilinear math. You can move the exponents around. If you are ever bored, then please look for a trilinear mapping, and it would make a lot of cryptographers happy, and we don't know how to do that yet. Where you can pair three things together and multiply exponents.

This also implies some other properties-- if you pair G and u * v, this is the same as pairing ... so what can we do with this? So we can build so called BLS signatures. We need this elliptic curve... only a few have pairings. The secp256k1 curve in bitcoin is not pairing-friendly. And then we have a generator G, and a hash function that hashes into G in this elliptic curve.

How does the signing work? You hash the message into the group element and then raise it to the power of x. So this looks like a signature, but hwo do we verify it? How an we use G, the public key, and the signature and the message to verify it? I am going to give you the firs tpart of this, the signature with G, and anyboy want to take a stab at this? I think it's too big of an audience for this. What can we do with this? This is atually, if you think about it, this is equivalent to pairing the hash of the message with the upublic key. And so let's look at this in more detail. What is sigma? It was H(m) to the x. So this statement is the same as H(m^x) but we can move this x exponent around because this is a pairing, it's the property that a pairing gives us. And then we get the final verification. This has a couple of nice properties.

One of the first ones is that the signature is very short. It's a single group element, about 32 bytes depending on how much security you want. This is one nice signature. Another nice signature is that it's deterministic. Given a message and a hash, the signature is just the hash of the message raised to the power x. There is no randomness like in ECDSA or Schnorr signatures. There is some work on definities to use this as creating a randomness beacon. If I have a public key and a message, there will only ever be one signature for that message. Malleability is not an issue, because it's deterministic.

The other really cool property that BLS has is signature aggregation. Say I have two different signatures from two different people and ompletely separate signatures. What if I just multiplied them together? Sigma 1 times sigma 2. Can I still verify that, given only sigma, and not sigma 1 and sigma 2? Let's remember this is the normla pairing, signature verification for BLS... but what if we just kind of do the thing on the left? What does this expand to? So you can verify the first signature and the second signature, and this is the final equation over here for the whole pairing. Why does this matter?

Why do we care about signature aggregation? Welll, tthink about it. say we have m different messages and they are not related. But they have different signatures. Now we can take all the signatures, smoosh them togethre and get a single signature on all the transactions. You just multiply them together. It's a single signature.

What's another nice property we might want from signatures? The thing about these signatures and things in bitcoin that we just heard a lot about it. There's this different property that is stronger than multisig, it's called threshold signatures. Say we have m different parties and we wanted to do this keygen to generate their own keys and we wanted a threshold of them so that t can sign a message. The important thing is that the signature is does not grow with the threshold. It's still a single signautre. It's different from multisig where it's literally just concatenating the signatures together. So if you have a thousand out of 500, 500 of 1000 multisig, then you need to concatenate 500 signatures together. But in threshold signatures, you have a single signature that looks like one person signed it. This is good for privacy because the amount only reveals.. whether it was multisig or just a threshold signature. This is very difficult for ECDSA but there's been some work on ... in 2016.. Gennano et al 2016. It's very easy in schnorr signatures. You can do this with 1k out of 2k keys, or even 3 out of 1k keys, etc. It will still look like a normal signature, the blockchain doesn't need CHECKMULTISIG, just needs CHECKSCHNORRSIG or CHECKBLS or something.

It's basically- you build this polynomial and every party gets a different point on this polynomial and then if you have enough people, if you have enough threshold they will be able to reconstruct the polynomials just from the points. And then the secret key is just this special point on the polynomial evaluated to zero.

The next signature type that I might be interested is the ring signature. It looks similar to a threshold signature but it's actually idfferent. We have a set of parties, forming a so called ring, which is where the name comes from. One of them, once you create a signature, nobody should be able to tell who of them signed the message. So there's no linkability. This came up in early e-cash protocols. If you ever want to use ring signatures, probably use the logarithmic one.

I'll skip over blind signatures for today.

I want to go straight to zero-knowledge proofs of knowledge. It's a very hyped topic. There's also zk-SNARKs and NIZKs. What are the differences? What is a zero-knowledge proof of knowledge? It works as follows. Alice says she knows a solution to a complex euqation, or the decyrption of an encryption that has some properties, some knowledge. I know this, and it has some properties. And then Bob says, prove it. And one solution obviously to prove it is to give the solution. You can just give the private key for example. But what if you don't want to reveal the solution? Is it possible? Surprisingly, I can convince you that I know the solution, without giving you any information about what the solution is. The way that we do that is through this challenge response protocol.

So you ask me questions that I would not be able to answer if I didn't know a solution. Hwever, the answers to these questions reveals no information about the solution. This can be in multiple rounds. In the end, Bob will have no idea what the solution is, but Alice must know it, otherwise she would not have been able to answer these questions. It's counterinuitive but it's possible. And zero-knowledge proofs have tons of applications in bitcoin, many related to confidentiality, privacy, mimblewimble, zerocash, and so on and so forth and many more.

Let's do a concrete example of sudoku. Say you wanted to do a zero knowledge contingent payment based on a sudoku puzzle solution, where you want the payment in exchange for the solution. So first we prove that I have the solution, and once oyu're convinced, you pay me on condition that I reveal the solution. And the payment is in the blockchain and it's irrevocable.

There is a zero-knowledge sudoku paper from 2005 (Gradwohl et al., 2005).

<https://bitcoincore.org/en/2016/02/26/zero-knowledge-contingent-payments-announcement/>









