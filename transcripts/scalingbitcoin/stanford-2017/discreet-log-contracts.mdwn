Discreet log contracts

<http://diyhpl.us/wiki/transcripts/discreet-log-contracts/>

<https://www.youtube.com/watch?v=FU-rA5dkTHI>

paper: <https://adiabat.github.io/dlc.pdf>

Hello everyone. I am going to give a talk about discreet log contracts. I am from MIT DCI. I work on lightning network software and discreet log contracts. A quick intro: these are pretty new. I am not sure if they work. This presentation is part of the peer review process. Maybe the math doesn't work. Please let me know. It might also work, though.

It's a system of smart contracts using bitcoin which is similar to lightning network. Hopefully I can reuse a lot of code. People can't see the smart contracts though, that's why I use the word discreet instead of discrete. One refers to discrete log problem, the other one refers to discreet as in privacy. I will talk about smart contracts, elliptic urves, schnorr signatures, and then some other aspects.

A smart contract is a conditional payment where two people put in some money and based on some external data, that money moves. In this example, Alice and Bob are betting on tomorrow's weather. Another way to say conditional payment is betting. Insurance is similar. Like whether you crash your car-- and then the insurance company gives you money. In that context, well, we'll talk about weather since it's benign. Alice and Bob are going to bet on tomorrow's weather. If it rains, Alice gets a coin. And if it's sunny, then Bob gets a coin. We do not have an OP\_WEATHER opcode. So we need a smart contract.

You need an oracle. In the case of the lightning network, there is no external data. You are just sending data back and forth between the two parties. Lightning network needed those two contracts. If we want external state to cause something to happen in bitcoin, then we need something called na oracle. People have been looking at this for a while. A simple one is 2-of-3 multisig. I'll show you why discreet log contract is better. It's just 2-of-2, that means the conflict between the two parties freezes the funds forever. So they both put in 0.5 coin, and based on the weather they want some outcome. If they agree, it's great, but if not it doesn't work. And this benefits rich people because he can just indefinitely lose the coins or give you a bad deal or something. So 2-of-2 mutlisig doesn't work because they can just indefinitely bully you into some other deal at the end.

A third party can decide in cases of conflict... you can have 3 keys, Alice, Bob and Olivia. If Alice and Bob are chill they can both agree and sign and get the outcome. If they are fighting though, or offline or unresponsive, either one of them can go to Olivia and tell her hey it rained, so sign tihs. Otherwise they say, hey, it's raining, I'll give you 0.8 BTC... and then they can collude with the oracle. The oracle is corruptible. A 2-of-3 multisig oracle.. it's interactive. Not only do they see every contract but they are also deciding the outcome. They deicde everything. And they can equivocate. They can say okay it's raining and they will sign off on that.. but give a different answer to some other contract. So these oracles have a lot of power. It would be better if an oracle couldn't equivocate, and if the oracle didn't know the contract details at all.

I'll go into this real quick. Basically, schnorr signatures are a signature system that is actually easier to understand than ECDSA which is currently used in bitcoin. A little letter is a scalar, capital letters are points on an eliptic curve, make a keypar where you come up with a random number, multiply it by G a generator point a random point that everyone agrees on, then you have the Hash function H and ... the message. In schnorr signatures, you come up with a random nonce k which is similar to lowercase a, you multiply k by the generator point G to get r. This r point is used in the signature. To sign, you compute s, which is k minus the H(message) and your R point, multiplied by your private key. In schnorr signature, there's no... there's a cpaital letter that you have to compute R from k. But there's no elliptic curve math... you multiply, then you subtract all of that from k. This is all modulo a big prime number. The signature is the pair (R, s). R is a point, s is a scalar. They are both about 32 bytes. To verify a signature, given the private key and the message, you need, ... you know what R is, because that's the signature, you know what s is, that's part of the signature. You know what their public key is, and you know the message. So you take this signing equation and multiply both sides by the generator point G. So the signature is s = k - H(m, R) * a. And the signature is (R, s). And to verify, s * G = kG - H(m, R) * (a * G). Which equals R - H(m, R) * A. So that's how schnorr signatures work.

What if instead of having the public key be A and the signature having (R, s) then what about giving the public key and also making an R value at the same time. Instea dof my public key being A and my signature (R, s) I can just say my pubkey is (A, R) and my signature is s. When i'm making a public key, I'm making ... two random scalars multiplied by the generator point G. I can do the same equation with the message, get an s, and then my pubkey is twice as large, my signature is half as large. The equations are the same. This intuitively seems ot work. It's the same thing, but you can only sign once. If you signed two of the same messages with the same public key and same k value, then you can compute someone's private key. This actually happened-- this is how playstation a number of years ago... you have to make sure you don't reuse R values. This is why you should rather commit to a single pubkey and come up with a new R value. You can only make a single signature with this new pubkey this new pair. In this case, it's a good thing.

Given a new public key, a publi key which we now call (A, R) and a message m, you can't forge a signature just like in normal schnorr signature schem. But you can compute s * G which is just going to be the right-hand side of the verification equation, which is R - H(m, R) * A. And s * G is computable for any given message, but you don't know what s is, that's the discrete log problem. It's an unknown scalar but you know what it is times the generator point. This seems a lot like a keypair. It's not how it's traditionally used, but it's the same thing.

You can think of Olivia's signature as a private key, and s * G is a public key. Signatures as private keys. We are going to use the oracle's signature as a private key, we don't know what it is yet, but we know what it might look like .So we can add that point to our own points. Alice's public key plus this signature times generator point, we can call it a contract public key. Alice's private key, with elliptic curve homomorphism will be out the signature plus their public key... The other part you need to sign with will be the oracle's signature.

Given this new ability to sort of combine signatures and private keys to make key pairs, you can create discreet log contracts. It looks a lot like lightning payment channels. You have a funding transaction where both parties put in coins. Then you create a bunch of double spends. In lightning, you create a bunch of sequential double spends and you enforce rules through the channel that only the recent transaction is valid and broadcastable. However, in discreet log contracts, we make all 3 transactions at once and we don't know which one will be valid. It's dependent on the oracle revealing some signature in the future. Based on what the oracle signs, these public keys are now spendable. We will know the private keys for one of these outcomes.

Say Olivia signs the message "it's rainy". Olivia's signature is ... it's the partial private key for state 2. So state 2 has now been endorsed by Olivia as the correct state. And then Alice and Bob can spend from that transaction, and the other transactions will not be spendable.


